var app = angular.module('ASMSimulator', []);

;app.service('assembler', ['opcodes', 'constants', function (opcodes, constants) {
    return {
        go: function (input) {
            // Use https://regex101.com/
            // Matches: "label: INSTRUCTION (["')OPERAND1(]"'), (["')OPERAND2(]"')
            // GROUPS:      1       4               6                    14
            var regex = /^[\t\s]*(?:([_.A-Za-z]\w*)([:]|([\t\s]*[=])))?(?:[\t\s]*([.A-Za-z]{2,5}(,[A-Za-z]{2})?)?(?:[\t\s]*((\#?([B']{2}[01]{1,8})?([H']{2}[0-9a-fA-F]{1,3})?\d*\"?\w*\"?)?([\t\s]*(\+|\-|\/|\*)?[\t\s]*(\d*|\w*|(\{[ABXYSPC]{1,2}\})))*)?)?(?:[\s\t ]*[,:][\s\t ]*((\#?([B']{2}[01]{1,8})?([H']{2}[0-9a-fA-F]{1,3})?\d*\"?\w*\"?)?((\+|\-)?(\d*|\w*|(\{[ABXYSPC]{1,2}\}))){0,2})?)?)?([\s\t]*($|;))/;
            
            //DEBUG
            var debug = false;

            // Regex group indexes for operands
            var label_group = 1;
            var constant_group = 3; // recupère le =
            var instr_group = 4;
            var op1_group = 6;
            var op2_group = 14;

            // MATCHES: "(+|-)INTEGER"
            var regexNum = /^[-+]?[0-9]+$/;
            // MATCHES: "(.L)abel"
            var regexLabel = /^[.A-Za-z]\w*$/;
            // NK MATCHES: "(.C)onstant"
            var regexConstant = /^[_A-Za-z]\w*$/;

            // Contains the program code & data generated by the assembler
            var code = [];
            // Contains the mapping from instructions to assembler line
            var mapping = {};
            // Hash map of label used to replace the labels after the assembler generated the code
            var labels = {};
            // Hash of uppercase labels used to detect duplicates
            var normalizedLabels = {};

            //NK labels version dauphin
            var labels_dauph = {};
            //var current_label = 'None'

            // Split text into code lines
            var lines = input.split('\n');

            
            // Allowed formats: 200, 200d, 0xA4, 0o48, 101b
            var parseNumber = function (input) {
                if (input.slice(0, 2) === "0x" || input.slice(0, 2) === "H'") {
                    return parseInt(input.slice(2), 16);
                } else if (input.slice(0, 2) === "0o" || input.slice(0, 2) === "O'") {
                    return parseInt(input.slice(2), 8);
                } else if (input.slice(input.length - 1) === "b") {
                    return parseInt(input.slice(0, input.length - 1), 2);
                }else if (input.slice(0, 2) === "B'"){
                    return parseInt(input.slice(2), 2);
                } else if (input.slice(input.length - 1) === "d") {
                    return parseInt(input.slice(0, input.length - 1), 10);
                } else if (input.slice(0, 2) === "D'"){
                    return parseInt(input.slice(2), 10);
                } else if (regexNum.exec(input)) {
                    return parseInt(input, 10);
                } else {
                    
                    return undefined
                }
            };

            // Allowed registers: A, B, X, Y, SP
            var parseRegister = function (input) {
                input = input.toUpperCase();

                if (input === 'A') {
                    return 0;
                } else if (input === 'B') {
                    return 1;
                } else if (input === 'X') {
                    return 2;
                } else if (input === 'Y') {
                    return 3;
                } else if (input === 'SP') {
                    return 4;
                } else if (input === 'PC') {
                    return 8;
                } else {
                    return undefined;
                }
            };

            // Allowed: Register, Label or Number; SP+/-Number is allowed for 'regaddress' type
            var parseRegOrNumber = function (input, typeReg, typeNumber) {
                var debug = false;
                if (debug) console.log('parseRegOrNumber - START', input);

                var register = parseRegister(input);

                if (register !== undefined) {
                    if (debug) console.log('parseRegOrNumber - 1 - register');
                    return {type: typeReg, value: [register]}; //nk value array

                } else {
                    if (debug) console.log('parseRegOrNumber - 2 - label');

                    var label = parseLabel(input);
                    if (label !== undefined) {
                        if (debug) console.log('parseRegOrNumber - 2.1 - label');
                        var constant = parseConstant(input.trim()); // NK
                        if (constant !== undefined && constants[constant.toUpperCase()] !== undefined) {
                            if (debug) console.log('parseRegOrNumber - 2.2 - constant',constant);
                            return {type: constants[constant.toUpperCase()].type, value: [constants[constant.toUpperCase()].value]}; // nk est nécessaire d'enregistrer le type dans constants?
                        } else {
                            return {type: 'address', value: [0, label]};
                        };

                    } else {
                        if (debug) console.log('parseRegOrNumber - 2.3 - constant',input);
                        var constant = parseConstant(input.trim()); // NK
                        
                        if (constant !== undefined && constants[constant.toUpperCase()] !== undefined) {
                            if (debug) console.log('parseRegOrNumber - 3 - constant',constant);
                            return {type: constants[constant.toUpperCase()].type, value: [constants[constant.toUpperCase()].value]}; // nk est nécessaire d'enregistrer le type dans constants?
                        } else {
                            if (debug) console.log('parseRegOrNumber - 4 - number', input);
                            var value = parseNumber(input);
                            
                            if (isNaN(value)) {
                                throw "Not a " + typeNumber + ": " + value;
                            }else if (value < 0 && value>=-128 && typeNumber !== 'address'){
                                value = 256+value;
                            } else if (value<-128){
                                throw "signed number must have a value between -128-127";
                            }else if (value > 256 && typeNumber !== 'address') {
                                throw typeNumber + " must have a value between 0-256";
                            }

                            return {type: typeNumber, value: [value]};
                        }
                    }
                }
            };

            var parseLabel = function (input) {
                return regexLabel.exec(input) ? input : undefined;
            };

            //nk
            var parseConstant = function (input) {
                return regexConstant.exec(input) ? input : undefined;
            };

            //nk converti une adresse 12bits en 2 octets
            var parseAddressValue = function (value, offset=0) {
                var debug = false;
                if (!Array.isArray(value) || value.length<2){ // premier appel. Si indexed address on veut juste ajouter l'offset
                    if (Array.isArray(value)) value = value[0];
                    var value_table = [0, 0];
                    if (value > 255){
                        value_table[0] = (value-value%256)/256;
                        value_table[1] = value%256;
                    } else if (value<0){
                        value = 256+value; // seulement pour les address relative -> value -128;127
                        value_table[0] = (value-value%256)/256;
                        value_table[1] = value%256;
                    } else {
                        value_table[1] = value;
                    }
                } else {
                    value_table = value;
                };
                // offset=0;
                if (debug) console.log(value_table[0],value_table[1]);
                value_table[0] += 16*offset; // indexed address +{X} or {SP}+depl
                if (debug) console.log(value_table[0],value_table[1]);
                return value_table;
           
                
            };

            var parseOperation = function (input){ // operation and indexed address
                var debug = false;
                var value, value_list=[], op=[], i=0;
                input= input.trim();
                var opIndex = input.search(/[\+\-\/\*]/);
                // check if indexed address
                if (input.search('{') == opIndex+1){ //// val+{X/Y}
                    if (debug) console.log('parseRegOrNumber - 2.2 - indexed address');
                        
                    var idx = [input.indexOf('{'), input.lastIndexOf("{")];
                    var base = getValue(input.slice(0,idx[0]-1));

                    if (debug) console.log(idx,base);
                    if (idx[0]===idx[1]){
                        var register = parseRegister(input.slice(idx[0]+1,idx[0]+2));
                        if (register !== undefined && (register == 2 || register == 3)){
                            var value = parseAddressValue(base.value,register-1);
                            return {type: 'address', value: value};
                        } else {
                            throw "2 format indexed address not supported"
                        }
                        
                    } else {
                        var register1 = parseRegister(input.slice(idx[0]+1,idx[0]+2));
                        var register2 = parseRegister(input.slice(idx[1]+1,idx[1]+2));
                        if (register1 !== undefined && register2 !== undefined && (register1 == 2 || register1 == 3) && (register2 == 2 || register2 == 3)){
                            var value = parseAddressValue(base.value,3);
                            return {type: 'address', value: value};
                        } else {
                            throw "3 format indexed address not supported"
                        }
                    };                    
                } else if (input.search('}') == opIndex-1){  // {SP/PC}+val
                    var register = parseRegister(input.slice(1,3));
                    if (debug) console.log(register);
                    if (register !== undefined && (register == 4 || register == 8)){
                        var depl = parseInt(input.slice(4))
                        var value = parseAddressValue(depl,register);
                        return {type: 'address', value: value};
                    } else {
                        throw "1 format indexed address not supported"
                    }
                } else if (input[0]=='#' && opIndex==1 && input[opIndex]=='-'){ // nombre négatif #-1
                    var value = parseInt(input.slice(1));
                    value = 256+value;
                    return {type: 'number', value: [value]}
                }

                while(opIndex>-1){
                    if (debug) console.log('while1', value_list, op, input)
                    value_list[i] = getValue(input.slice(0,opIndex).trim());
                    op[i] = input[opIndex];
                    input = '#' + input.slice(opIndex+1).trim(); // forcement des nombes les arguments suivants
                    var opIndex = input.search(/[\+\-\/\*]/);
                    i++
                    if (debug) console.log('while2', value_list, op, input)
                };
                // if (debug) console.log(input,i)
                
                value_list[i] = getValue(input);
                
                if (debug) console.log('parseOperation-End', value_list, op, value);
                if (value_list[0].type == 'address'){
                    if (debug) console.log('for-start-address', value_list, op, input, value)
                    var value = value_list[0].value[1]+value_list[0].value[0]*256;
                    for (j=1; j<=op.length; j++){
                        if (op[j-1]=='\+'){
                            value += value_list[j].value[0];
                        }else if (op[j-1]=='\-'){
                            value -= value_list[j].value[0];
                        }else if (op[j-1]=='\*'){
                            value *= value_list[j].value[0];
                        }else if (op[j-1]=='\/'){
                            value = ~~(value/value_list[j].value[0]);
                        }else {
                            throw "operation not supported: " + op[j-1]
                        };
                    };
                    
                    return {type: value_list[0].type, value: parseAddressValue(value)}
                }else{
                    value = value_list[0].value[0];
                    if (debug) console.log('for-start-number', value_list, op, input, value)
                    for (j=1; j<=op.length; j++){
                        if (op[j-1]=='\+'){
                            value += value_list[j].value[0];
                        }else if (op[j-1]=='\-'){
                            value -= value_list[j].value[0];
                        }else if (op[j-1]=='\*'){
                            value *= value_list[j].value[0];
                        }else if (op[j-1]=='\/'){
                            value = ~~(value/value_list[j].value[0]);
                        }else {
                            throw "operation not supported: " + op[j-1]
                        };
                    };
                    return {type: value_list[0].type, value: [value]};
                };
            };

            var getValue = function (input) {
                var debug = false;
                if (debug) console.log('getValue - START:', input);
                var value = {}
                // pkoi a t il fallut remplacer le switch par un if (sinon " -> case " ET -> case' ???)

                // tester si l'expression contient des opération +-*/
                if (input.search(/[\+\-\/\*]/)>-1){
                    var value = parseOperation(input);
                    return value;
                };

                if (input.slice(0, 1) === '#') { // #number
                    if (debug) console.log('getValue - 1 - Number', input);
                        input = input.trim(); // enleve espace tabulation pas triée avec le regex
                        var value = parseNumber(input.slice(1));
                        if (debug) console.log(value, input);
                        if (value == undefined || isNaN(value)) { //NK trick dans parseNumber (pas très joli)
                            if (input.slice(0, 2) === '#"'){
                                if (debug) console.log('getValue - 1.1 - Number.char', input);
                                value =  getValue(input.slice(1)).value[0]; // rappele la routine en enlevant le #
                            } else if(constants[input.slice(1).trim().toUpperCase()] !== undefined){
                                if (debug) console.log('getValue - 1.1 - Number.const', input);
                                value = constants[input.slice(1).trim().toUpperCase()] .value
                            }else{
                                throw "Not a " + "number" + ": " + value;
                            }
                        }
                        else if (value > 256){
                            throw "Number must have a value between 0-256";
                        } else if (value < 0 && value>=-128){
                            value = 256+value; // value<0
                        }else if (value<-128){
                            throw "signed number must have a value between -128-127";
                        }

                    return {type: "number", value: [value]};

                } else if (input.slice(0, 1)==='"'){ // "String" //NK y a jouter aussi les table (type: numberS)
                        if (debug) console.log('getValue - 2 - String');
                        var text = input.slice(1, input.length - 1);
                        var chars = [];
                        if (text.length > 1){
                            for (var i = 0, l = text.length; i < l; i++) {
                                chars.push(text.charCodeAt(i));
                            }

                            value = {type: "table", value: chars}; //nk deja un array
                        } else if (text.length == 1){
                            value = {type: "number", value: [text.charCodeAt(0)]}; //nk value array
                        } else {
                            throw "String not valid"
                        }
                        return value;

                }else{ // REGISTER or LABEL or CONSTANT or indexedADDRESS{}
                        if (debug) console.log('getValue - 4 - else');
                        value = parseRegOrNumber(input.trim(), "register", "address");

                        if ((value.type === 'address' || value.type === 'routine')&& angular.isNumber(value.value[value.value.length-1])){ // pour les labels il faudra le faire plus tard (Question: comment deja preparer la place pour un 2eme octet???)
                            if (debug) console.log('getValue - 5 - parseAddressValue');
                            value.value = parseAddressValue(value.value);
                        }
                }

                
                if (debug) console.log('getValue - END:', value)
                return value
            };

            var addLabel = function (label) {
                var upperLabel = label.toUpperCase();
                if (upperLabel in normalizedLabels)
                    throw "Duplicate label: " + label;

                if (upperLabel === "A" || upperLabel === "B" || upperLabel === "X" || upperLabel === "Y")
                    throw "Label contains keyword: " + upperLabel;
                
                labels[label] = code.length;
                current_label = label;
            };

            // NK dauphin lables
            var addLabel_dauph = function (instr, address, p1, p2, code) {
               
                var dauph = {};

                dauph.address = address;
                dauph.code = code;
                dauph.array = []
                dauph.array[0] = instr;
                if (p1.value !== undefined){
                    dauph.array = dauph.array.concat(p1.value);                    
                }
                if (p2.value !== undefined){
                    dauph.array = dauph.array.concat(p2.value);
                }
                // Pour que les entrée soit dans l'ordre croissant
                if (address<10){
                    labels_dauph['00' + address.toString()] = dauph;    
                } else if (address<100){
                    labels_dauph['0' + address.toString()] = dauph;  
                } else {
                    labels_dauph[address] = dauph;
                    
                }

                mapping[address][1] = Object.keys(labels_dauph).length
            };


            var checkNoExtraArg = function (instr, arg) {
                if (arg !== undefined) {
                    throw instr + ": too many arguments";
                }
            };

            for (var i = 0, l = lines.length; i < l; i++) {
                try {
                    var match = regex.exec(lines[i]);
                    if (debug) console.log(lines[i]);
                    if (debug) console.log('regex:',match);
                    if (debug) console.log(match[label_group], match[instr_group]);
                    if (match[label_group] !== undefined || match[instr_group] !== undefined) {
                        if (match[label_group] !== undefined) {
                            if (match[constant_group] == undefined){
                                addLabel(match[label_group]);
                            }else{
                                var constant = getValue(match[6]);
                                constant.value = constant.value[0]*256+constant.value[1];
                                constants[match[label_group].trim().toUpperCase()] = constant;
                            }
                        }

                        if (match[instr_group] !== undefined) {
                            var instr = match[instr_group].toUpperCase();
                            var p1 = {}, p2 = {}, opCode = {};
                            var address = code.length

                            // Add mapping instr pos to line number
                            // Don't do it for DB as this is not a real instruction
                            if (instr !== 'TABLE' && instr !== 'BYTE') { // NK remplacer par BYTE mais aussi les definition de constante
                                mapping[code.length] = [i];
                            }

                            switch (instr) {
                                // case '.LOC': // instruction pas compriss par le parsing
                                case 'BYTE':
                                case 'TABLE':
                                    p1 = getValue(match[op1_group]);
                                    // console.log('DB:', p1)
                                    if (p1.type === "number")
                                        code.push(...p1.value);
                                    else if (p1.type === "table")
                                        for (var j = 0, k = p1.value.length; j < k; j++) {
                                            code.push(p1.value[j]);
                                        }
                                    else{
                                        if (debug) console.log(code)
                                        throw "TABLE does not support this operand: " + p1.type;
                                    }
                                    break;
                                case 'HALT':
                                    checkNoExtraArg('HALT', match[op1_group]);
                                    opCode = opcodes.HALT;
                                    code.push(opCode);
                                    break;
                                case 'NOP':
                                    checkNoExtraArg('NOP', match[op1_group]);
                                    opCode = opcodes.NOP;
                                    code.push(opCode);
                                    break;    
                                case 'MOVE':
                                    if (debug) console.log('MOVE:', match[op1_group], match[op2_group]);
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    if (debug) console.log('MOVE:', p1, p2);
                                    if (p1.type === "register" && p2.type === "register"){
                                        if (p1.value[0]==0){
                                                opCode = opcodes.MOVE_A_TO_A + p2.value[0];
                                        } else if (p1.value[0]==1){
                                                opCode = opcodes.MOVE_B_TO_A + p2.value[0];
                                        } else if (p1.value[0]==2){
                                                opCode = opcodes.MOVE_X_TO_A + p2.value[0];
                                        } else if (p1.value[0]==3){
                                                opCode = opcodes.MOVE_Y_TO_A + p2.value[0];
                                        } else {
                                                throw "1 MOVE does not support this operands";
                                        };
                                        
                                        code.push(opCode);
                                        p1.value = undefined;
                                        p2.value = undefined;
                                    } else if (p1.type === "number" && p2.type === "register"){
                                        opCode = opcodes.MOVE_NUMBER_TO_A + p2.value[0];
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "register"){
                                        opCode = opcodes.MOVE_ADDRESS_TO_A + p2.value[0];
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "register" && p2.type === "address"){
                                        opCode = opcodes.MOVE_A_TO_ADDRESS + p1.value[0];
                                        code.push(opCode, ...p2.value);
                                        p1.value = undefined;
                                    } else if (p1.type === "number" && p2.type === "address"){
                                        opCode = opcodes.MOVE_NUMBER_TO_ADDRESS;
                                        code.push(opCode, ...p1.value, ...p2.value);
                                    }else{
                                        throw "2 MOVE does not support this operands";
                                    }
                                    
                                    break;
                                case 'ADD':
                                    if (debug) console.log('ADD:', match[op1_group], match[op2_group]);
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    if (debug) console.log('ADD:', p1, p2);
                                    if (p1.type === "register" && p2.type === "register"){
                                        if (p1.value[0]==0){
                                                opCode = opcodes.ADD_A_TO_A + p2.value[0];
                                        } else if (p1.value[0]==1){
                                                opCode = opcodes.ADD_B_TO_A + p2.value[0];
                                        } else if (p1.value[0]==2){
                                                opCode = opcodes.ADD_X_TO_A + p2.value[0];
                                        } else if (p1.value[0]==3){
                                                opCode = opcodes.ADD_Y_TO_A + p2.value[0];
                                        } else {
                                                throw "1 ADD does not support this operands";
                                        };
                                        
                                        code.push(opCode);
                                        p1.value = undefined;
                                        p2.value = undefined;
                                    } else if (p1.type === "number" && p2.type === "register"){
                                        if (p2.value <4){ // a, b, x, y
                                            opCode = opcodes.ADD_NUMBER_TO_A + p2.value[0];
                                        } else if (p2.value==4){ //SP
                                            opCode = opcodes.ADD_NUMBER_TO_SP;
                                        };
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "register"){
                                        opCode = opcodes.ADD_ADDRESS_TO_A + p2.value[0];
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "register" && p2.type === "address"){
                                        opCode = opcodes.ADD_A_TO_ADDRESS + p1.value[0];
                                        code.push(opCode, ...p2.value);
                                        p1.value = undefined;
                                    } else if (p1.type === "number" && p2.type === "address"){
                                        opCode = opcodes.ADD_NUMBER_TO_ADDRESS;
                                        code.push(opCode, ...p1.value, ...p2.value);
                                    }else{
                                        throw "2 ADD does not support this operands";
                                    }
                                    break;
                                case 'SUB':
                                    if (debug) console.log('SUB:', match[op1_group], match[op2_group]);
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    if (debug) console.log('SUB:', p1, p2);
                                    if (p1.type === "register" && p2.type === "register"){
                                        if (p1.value[0]==0){
                                                opCode = opcodes.SUB_A_TO_A + p2.value[0];
                                        } else if (p1.value[0]==1){
                                                opCode = opcodes.SUB_B_TO_A + p2.value[0];
                                        } else if (p1.value[0]==2){
                                                opCode = opcodes.SUB_X_TO_A + p2.value[0];
                                        } else if (p1.value[0]==3){
                                                opCode = opcodes.SUB_Y_TO_A + p2.value[0];
                                        } else {
                                                throw "1 SUB does not support this operands";
                                        };
                                        
                                        code.push(opCode);
                                        p1.value = undefined;
                                        p2.value = undefined;
                                    } else if (p1.type === "number" && p2.type === "register"){
                                        if (p2.value <4){
                                            opCode = opcodes.SUB_NUMBER_TO_A + p2.value[0];
                                        } else if (p2.value==4){
                                            opCode = opcodes.SUB_NUMBER_TO_SP;
                                        };
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "register"){
                                        opCode = opcodes.SUB_ADDRESS_TO_A + p2.value[0];
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "register" && p2.type === "address"){
                                        opCode = opcodes.SUB_A_TO_ADDRESS + p1.value[0];
                                        code.push(opCode, ...p2.value);
                                        p1.value = undefined;
                                    } else if (p1.type === "number" && p2.type === "address"){
                                        opCode = opcodes.SUB_NUMBER_TO_ADDRESS;
                                        code.push(opCode, ...p1.value, ...p2.value);
                                    }else{
                                        throw "2 SUB does not support this operands";
                                    }
                                    break;
                                case 'AND':
                                    if (debug) console.log('AND:', match[op1_group], match[op2_group]);
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    if (debug) console.log('AND:', p1, p2);
                                    if (p1.type === "register" && p2.type === "register"){
                                        if (p1.value[0]==0 && p2.value[0]==1){
                                                opCode = opcodes.AND_A_TO_B;
                                        } else if (p1.value[0]==1 && p2.value[0]==0){
                                                opCode = opcodes.AND_B_TO_A;
                                        } else {
                                                throw "1 AND does not support this operands";
                                        };
                                        
                                        code.push(opCode);
                                        p1.value = undefined;
                                        p2.value = undefined;
                                    } else if (p1.type === "number" && p2.type === "register"){
                                        opCode = opcodes.AND_NUMBER_TO_A + p2.value[0];
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "register" && p2.value[0]<=1){
                                        opCode = opcodes.AND_ADDRESS_TO_A + p2.value[0];
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "register" && p2.type === "address"){
                                        opCode = opcodes.AND_A_TO_ADDRESS + p1.value[0];
                                        code.push(opCode, ...p2.value);
                                        p1.value = undefined;
                                    }else{
                                        throw "2 AND does not support this operands";
                                    }
                                    break;
                                case 'OR':
                                    if (debug) console.log('OR:', match[op1_group], match[op2_group]);
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    if (debug) console.log('OR:', p1, p2);
                                    if (p1.type === "register" && p2.type === "register"){
                                        if (p1.value[0]==0 && p2.value[0]==1){
                                                opCode = opcodes.OR_A_TO_B;
                                        } else if (p1.value[0]==1 && p2.value[0]==0){
                                                opCode = opcodes.OR_B_TO_A;
                                        } else {
                                                throw "1 OR does not support this operands";
                                        };
                                        
                                        code.push(opCode);
                                        p1.value = undefined;
                                        p2.value = undefined;
                                    } else if (p1.type === "number" && p2.type === "register"){
                                        opCode = opcodes.OR_NUMBER_TO_A + p2.value[0];
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "register" && p2.value[0]<=1){
                                        opCode = opcodes.OR_ADDRESS_TO_A + p2.value[0];
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "register" && p2.type === "address"){
                                        opCode = opcodes.OR_A_TO_ADDRESS + p1.value[0];
                                        code.push(opCode, ...p2.value);
                                        p1.value = undefined;
                                    }else{
                                        throw "2 OR does not support this operands";
                                    }
                                    break;
                                case 'XOR':
                                    if (debug) console.log('XOR:', match[op1_group], match[op2_group]);
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    if (debug) console.log('XOR:', p1, p2);
                                    if (p1.type === "register" && p2.type === "register"){
                                        if (p1.value[0]==0 && p2.value[0]==1){
                                                opCode = opcodes.XOR_A_TO_B;
                                        } else if (p1.value[0]==1 && p2.value[0]==0){
                                                opCode = opcodes.XOR_B_TO_A;
                                        } else {
                                                throw "1 XOR does not support this operands";
                                        };
                                        
                                        code.push(opCode);
                                        p1.value = undefined;
                                        p2.value = undefined;
                                    } else if (p1.type === "number" && p2.type === "register"){
                                        opCode = opcodes.XOR_NUMBER_TO_A + p2.value[0];
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "register" && p2.value[0]<=1){
                                        opCode = opcodes.XOR_ADDRESS_TO_A + p2.value[0];
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "register" && p2.type === "address"){
                                        opCode = opcodes.XOR_A_TO_ADDRESS + p1.value[0];
                                        code.push(opCode, ...p2.value);
                                        p1.value = undefined;
                                    }else{
                                        throw "2 XOR does not support this operands";
                                    }
                                    break;  
                                case 'TEST':
                                    if (debug) console.log('TEST:', match[op1_group], match[op2_group]);
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    if (debug) console.log('TEST:', p1, p2);
                                    if (p1.type === "register" && p2.type === "register"){
                                        if (p1.value[0]==0 && p2.value[0]==1){
                                            opCode = opcodes.TEST_A_B;
                                        } else if(p1.value[0]==1 && p2.value[0]==0){
                                            opCode = opcodes.TEST_B_A;
                                        } else {
                                                throw "1 TEST does not support this operands";
                                        };                      
                                        code.push(opCode);
                                        p1.value = undefined;
                                        p2.value = undefined;
                                    } else if (p1.type === "register" && p2.type === "number"){
                                        if (p1.value[0]==0 || p1.value[0]==1){
                                            opCode = opcodes.TEST_A_NUMBER+p1.value[0];
                                        }else{
                                            throw "2 TEST does not support this operands";
                                        }
                                        code.push(opCode, ...p2.value);
                                        p1.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "register"){
                                        if (p2.value[0]==0 || p2.value[0]==1){
                                            opCode = opcodes.TEST_ADDRESS_A + p2.value[0];
                                        }else{
                                            throw "3 TEST does not support this operands";
                                        }
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "number"){
                                        opCode = opcodes.TEST_ADDRESS_NUMBER;
                                        code.push(opCode, ...p1.value, ...p2.value);
                                    }else{
                                        throw "4 TEST does not support this operands";
                                    }
                                    break;    
                                case 'TSET':
                                    if (debug) console.log('TSET:', match[op1_group], match[op2_group]);
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    if (debug) console.log('TSET:', p1, p2);
                                    if (p1.type === "register" && p2.type === "register"){
                                        if (p1.value[0]==0 && p2.value[0]==1){
                                            opCode = opcodes.TSET_A_B;
                                        } else if(p1.value[0]==1 && p2.value[0]==0){
                                            opCode = opcodes.TSET_B_A;
                                        } else {
                                                throw "1 TSET does not support this operands";
                                        };                      
                                        code.push(opCode);
                                        p1.value = undefined;
                                        p2.value = undefined;
                                    } else if (p1.type === "register" && p2.type === "number"){
                                        if (p1.value[0]==0 || p1.value[0]==1){
                                            opCode = opcodes.TSET_A_NUMBER+p1.value[0];
                                        }else{
                                            throw "2 TSET does not support this operands";
                                        }
                                        code.push(opCode, ...p2.value);
                                        p1.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "register"){
                                        if (p2.value[0]==0 || p2.value[0]==1){
                                            opCode = opcodes.TSET_ADDRESS_A + p2.value[0];
                                        }else{
                                            throw "3 TSET does not support this operands";
                                        }
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "number"){
                                        opCode = opcodes.TSET_ADDRESS_NUMBER;
                                        code.push(opCode, ...p1.value, ...p2.value);
                                    }else{
                                        throw "4 TSET does not support this operands";
                                    }
                                    break; 
                                case 'TCLR':
                                    if (debug) console.log('TCLR:', match[op1_group], match[op2_group]);
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    if (debug) console.log('TCLR:', p1, p2);
                                    if (p1.type === "register" && p2.type === "register"){
                                        if (p1.value[0]==0 && p2.value[0]==1){
                                            opCode = opcodes.TCLR_A_B;
                                        } else if(p1.value[0]==1 && p2.value[0]==0){
                                            opCode = opcodes.TCLR_B_A;
                                        } else {
                                                throw "1 TCLR does not support this operands";
                                        };                      
                                        code.push(opCode);
                                        p1.value = undefined;
                                        p2.value = undefined;
                                    } else if (p1.type === "register" && p2.type === "number"){
                                        if (p1.value[0]==0 || p1.value[0]==1){
                                            opCode = opcodes.TCLR_A_NUMBER+p1.value[0];
                                        }else{
                                            throw "2 TCLR does not support this operands";
                                        }
                                        code.push(opCode, ...p2.value);
                                        p1.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "register"){
                                        if (p2.value[0]==0 || p2.value[0]==1){
                                            opCode = opcodes.TCLR_ADDRESS_A + p2.value[0];
                                        }else{
                                            throw "3 TCLR does not support this operands";
                                        }
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "number"){
                                        opCode = opcodes.TCLR_ADDRESS_NUMBER;
                                        code.push(opCode, ...p1.value, ...p2.value);
                                    }else{
                                        throw "4 TCLR does not support this operands";
                                    }
                                    break; 
                                case 'TNOT':
                                    if (debug) console.log('TNOT:', match[op1_group], match[op2_group]);
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    if (debug) console.log('TNOT:', p1, p2);
                                    if (p1.type === "register" && p2.type === "register"){
                                        if (p1.value[0]==0 && p2.value[0]==1){
                                            opCode = opcodes.TNOT_A_B;
                                        } else if(p1.value[0]==1 && p2.value[0]==0){
                                            opCode = opcodes.TNOT_B_A;
                                        } else {
                                                throw "1 TNOT does not support this operands";
                                        };                      
                                        code.push(opCode);
                                        p1.value = undefined;
                                        p2.value = undefined;
                                    } else if (p1.type === "register" && p2.type === "number"){
                                        if (p1.value[0]==0 || p1.value[0]==1){
                                            opCode = opcodes.TNOT_A_NUMBER+p1.value[0];
                                        }else{
                                            throw "2 TNOT does not support this operands";
                                        }
                                        code.push(opCode, ...p2.value);
                                        p1.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "register"){
                                        if (p2.value[0]==0 || p2.value[0]==1){
                                            opCode = opcodes.TNOT_ADDRESS_A + p2.value[0];
                                        }else{
                                            throw "3 TNOT does not support this operands";
                                        }
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "number"){
                                        opCode = opcodes.TNOT_ADDRESS_NUMBER;
                                        code.push(opCode, ...p1.value, ...p2.value);
                                    }else{
                                        throw "4 TNOT does not support this operands";
                                    }
                                    break; 
                                case 'INC':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg('INC', match[op2_group]);

                                    if (p1.type === "register"){
                                        opCode = opcodes.INC_A + p1.value[0];
                                        code.push(opCode);
                                        p1.value = undefined;
                                    } else if (p1.type === "address"){
                                        opCode = opcodes.INC_ADDRESS;
                                        code.push(opCode, ...p1.value);
                                    }else{
                                        throw "INC does not support this operand";
                                    };
                                    
                                    break;
                                case 'DEC':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg('DEC', match[op2_group]);

                                    if (p1.type === "register"){
                                        opCode = opcodes.DEC_A + p1.value[0];
                                        code.push(opCode);
                                        p1.value = undefined;
                                    } else if (p1.type === "address"){
                                        opCode = opcodes.DEC_ADDRESS;
                                        code.push(opCode, ...p1.value);
                                    }else{
                                        throw "DEC does not support this operand";
                                    };
                                    
                                    break;
                                case 'NOT':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg('NOT', match[op2_group]);

                                    if (p1.type === "register"){
                                        opCode = opcodes.NOT_A + p1.value[0];
                                        code.push(opCode);
                                        p1.value = undefined;
                                    } else if (p1.type === "address"){
                                        opCode = opcodes.NOT_ADDRESS;
                                        code.push(opCode, ...p1.value);
                                    }else{
                                        throw "NOT does not support this operand";
                                    };
                                    
                                    break;
                                case 'CLR':
                                        p1 = getValue(match[op1_group]);
                                        checkNoExtraArg('CLR', match[op2_group]);
    
                                        if (p1.type === "register"){
                                            opCode = opcodes.CLR_A + p1.value[0];
                                            code.push(opCode);
                                            p1.value = undefined;
                                        } else if (p1.type === "address"){
                                            opCode = opcodes.CLR_ADDRESS;
                                            code.push(opCode, ...p1.value);
                                        }else{
                                            throw "CLR does not support this operand";
                                        };
                                        
                                        break;
                                case 'COMP':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);

                                    if (debug) console.log('COMP:', p1, p2);
                                    if (p1.type === "register" && p2.type === "register"){
                                        if (p1.value[0]==0){
                                            opCode = opcodes.COMP_A_TO_A + p2.value[0];
                                        } else if (p1.value[0]==1){
                                                opCode = opcodes.COMP_B_TO_A + p2.value[0];
                                        } else if (p1.value[0]==2){
                                                opCode = opcodes.COMP_X_TO_A + p2.value[0];
                                        } else if (p1.value[0]==3){
                                                opCode = opcodes.COMP_Y_TO_A + p2.value[0];
                                        } else {
                                                throw "MOVE does not support this operands";
                                        };
                                        
                                        code.push(opCode);
                                        p1.value = undefined;
                                        p2.value = undefined;
                                    } else if (p1.type === "number" && p2.type === "register"){
                                        opCode = opcodes.COMP_NUMBER_TO_A + p2.value[0];
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "address" && p2.type === "register"){
                                        opCode = opcodes.COMP_ADDRESS_TO_A + p2.value[0];
                                        code.push(opCode, ...p1.value);
                                        p2.value = undefined;
                                    } else if (p1.type === "number" && p2.type === "address"){
                                        opCode = opcodes.COMP_NUMBER_TO_ADDRESS;
                                        code.push(opCode, ...p1.value, ...p2.value);
                                    }else{
                                        throw "COMP does not support this operands";
                                    }
                                    break;
                                case 'JUMP':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg('JMP', match[op2_group]);

                                    if ( p1.type === "address") // preparation dauphin
                                        opCode = opcodes.JUMP_ADDRESS;
                                    else
                                        throw "JMP does not support this operands";

                                    code.push(opCode, ...p1.value);
                                    break;
                                case 'JUMP,ZS':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg(instr, match[op2_group]);

                                    if (p1.type === "address")
                                        opCode = opcodes.JUMP_ZS_ADDRESS;
                                    else
                                        throw instr + " does not support this operand";

                                    code.push(opCode, ...p1.value);
                                    break;
                                case 'JUMP,EQ':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg(instr, match[op2_group]);

                                    if (p1.type === "address")
                                        opCode = opcodes.JUMP_EQ_ADDRESS;
                                    else
                                        throw instr + " does not support this operand";

                                    code.push(opCode, ...p1.value);
                                    break;
                                case 'JUMP,ZC':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg(instr, match[op2_group]);

                                    if (p1.type === "address")
                                        opCode = opcodes.JUMP_ZC_ADDRESS;
                                    else
                                        throw instr + " does not support this operand";

                                    code.push(opCode, ...p1.value);
                                    break;
                                case 'JUMP,NE':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg(instr, match[op2_group]);

                                    if (p1.type === "address")
                                        opCode = opcodes.JUMP_NE_ADDRESS;
                                    else
                                        throw instr + " does not support this operand";

                                    code.push(opCode, ...p1.value);
                                    break;
                                case 'JUMP,LS':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg(instr, match[op2_group]);

                                    if (p1.type === "address")
                                        opCode = opcodes.JUMP_LS_ADDRESS;
                                    else
                                        throw instr + " does not support this operand";

                                    code.push(opCode, ...p1.value);
                                    break;
                                case 'JUMP,CS':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg(instr, match[op2_group]);

                                    if (p1.type === "address")
                                        opCode = opcodes.JUMP_CS_ADDRESS;
                                    else
                                        throw instr + " does not support this operand";

                                    code.push(opCode, ...p1.value);
                                    break;
                                case 'JUMP,HI':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg(instr, match[op2_group]);

                                    if (p1.type === "address")
                                        opCode = opcodes.JUMP_HI_ADDRESS;
                                    else
                                        throw instr + " does not support this operand";

                                    code.push(opCode, ...p1.value);
                                    break;
                                case 'JUMP,CC':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg(instr, match[op2_group]);

                                    if (p1.type === "address")
                                        opCode = opcodes.JUMP_CC_ADDRESS;
                                    else
                                        throw instr + " does not support this operand";

                                    code.push(opCode, ...p1.value);
                                    break;
                                case 'JUMP,LO':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg(instr, match[op2_group]);

                                    if (p1.type === "address")
                                        opCode = opcodes.JUMP_LO_ADDRESS;
                                    else
                                        throw instr + " does not support this operand";

                                    code.push(opCode, ...p1.value);
                                    break;
                                case 'JUMP,HS':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg(instr, match[op2_group]);

                                    if (p1.type === "address")
                                        opCode = opcodes.JUMP_HS_ADDRESS;
                                    else
                                        throw instr + " does not support this operand";

                                    code.push(opCode, ...p1.value);
                                    break;
                                case 'JUMP,NS':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg(instr, match[op2_group]);

                                    if (p1.type === "address")
                                        opCode = opcodes.JUMP_NS_ADDRESS;
                                    else
                                        throw instr + " does not support this operand";

                                    code.push(opCode, ...p1.value);
                                    break;
                                case 'JUMP,NC':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg(instr, match[op2_group]);

                                    if (p1.type === "address")
                                        opCode = opcodes.JUMP_NC_ADDRESS;
                                    else
                                        throw instr + " does not support this operand";

                                    code.push(opCode, ...p1.value);
                                    break;
                                case 'PUSH':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg('PUSH', match[op2_group]);

                                    if (p1.type === "register"){
                                        opCode = opcodes.PUSH_A + p1.value[0];
                                        code.push(opCode);
                                        p1.value = undefined;
                                    } else if (p1.type === "address"){
                                        opCode = opcodes.PUSH_ADDRESS;
                                        code.push(opCode, ...p1.value);
                                    }else{
                                        throw "PUSH does not support this operand";
                                    };
                                    
                                    break;
                                case 'POP':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg('POP', match[op2_group]);

                                    if (p1.type === "register"){
                                        opCode = opcodes.POP_A + p1.value[0];
                                        code.push(opCode);
                                        p1.value = undefined;
                                    } else if (p1.type === "address"){
                                        opCode = opcodes.POP_ADDRESS;
                                        code.push(opCode, ...p1.value);
                                    }else{
                                        throw "POP does not support this operand";
                                    };
                                    
                                    break;

                                case 'CALL':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg(instr, match[op2_group]);

                                    if (p1.type === "address"){ //nk add address
                                        opCode = opcodes.CALL_ADDRESS;
                                        // code.push(opCode, p1.value[0], p1.value[1]); //nk
                                    }else if (p1.type === "routine"){
                                        opCode = opcodes.CALL_ROUTINE;
                                    }else{
                                        throw "CALL does not support this operand";
                                    }
                                    code.push(opCode, ...p1.value);
                                    break;
                                case 'RET':
                                    checkNoExtraArg(instr, match[op1_group]);

                                    opCode = opcodes.RET;

                                    code.push(opCode);
                                    break;
                            
                                case 'RL':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg('RL', match[op2_group]);

                                    if (p1.type === "register"){
                                        opCode = opcodes.RL_A + p1.value[0];
                                        code.push(opCode);
                                        p1.value = undefined;
                                    } else if (p1.type === "address"){
                                        opCode = opcodes.RL_ADDRESS;
                                        code.push(opCode, ...p1.value);
                                    }else{
                                        throw "RL does not support this operand";
                                    };
                                    
                                    break;
                                case 'RR':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg('RR', match[op2_group]);

                                    if (p1.type === "register"){
                                        opCode = opcodes.RR_A + p1.value[0];
                                        code.push(opCode);
                                        p1.value = undefined;
                                    } else if (p1.type === "address"){
                                        opCode = opcodes.RR_ADDRESS;
                                        code.push(opCode, ...p1.value);
                                    }else{
                                        throw "RR does not support this operand";
                                    };
                                    
                                    break;
                                case 'RLC':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg('RLC', match[op2_group]);

                                    if (p1.type === "register"){
                                        opCode = opcodes.RLC_A + p1.value[0];
                                        code.push(opCode);
                                        p1.value = undefined;
                                    } else if (p1.type === "address"){
                                        opCode = opcodes.RLC_ADDRESS;
                                        code.push(opCode, ...p1.value);
                                    }else{
                                        throw "RLC does not support this operand";
                                    };
                                    
                                    break;
                                case 'RRC':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg('RRC', match[op2_group]);

                                    if (p1.type === "register"){
                                        opCode = opcodes.RRC_A + p1.value[0];
                                        code.push(opCode);
                                        p1.value = undefined;
                                    } else if (p1.type === "address"){
                                        opCode = opcodes.RRC_ADDRESS;
                                        code.push(opCode, ...p1.value);
                                    }else{
                                        throw "RRC does not support this operand";
                                    };
                                    
                                    break;
                                case 'SETC':
                                    checkNoExtraArg('SETC', match[op1_group]);
                                    opCode = opcodes.SETC;
                                    code.push(opCode);
                                    break;
                                case 'CLRC':
                                    checkNoExtraArg('CLRC', match[op1_group]);
                                    opCode = opcodes.CLRC;
                                    code.push(opCode);
                                    break;
                                case 'NOTC':
                                    checkNoExtraArg('NOTC', match[op1_group]);
                                    opCode = opcodes.NOTC;
                                    code.push(opCode);
                                    break;
                                case 'EX':
                                    p1 = getValue(match[op1_group]);
                                    p2 = getValue(match[op2_group]);
                                    if (p1.type === "register" && p2.type === "register"){
                                        if (p1.value[0]==0 && p2.value[0]==1){
                                                opCode = opcodes.EX_A_WITH_B;
                                        } else if (p1.value[0]==2 && p2.value[0]==3){
                                                opCode = opcodes.EX_X_WITH_Y;
                                        } else {
                                                throw "1 EX does not support this operands";
                                        };
                                        
                                        code.push(opCode);
                                        p1.value = undefined;
                                        p2.value = undefined;
                                    }
                                    break;
                                case 'SWAP':
                                    p1 = getValue(match[op1_group]);
                                    checkNoExtraArg('SWAP', match[op2_group]);
                                    if (p1.type === "register"){
                                        if (p1.value[0]==0){
                                            opCode = opcodes.SWAP_A;
                                        } else if (p1.value[0]==1){
                                            opCode = opcodes.SWAP_B;
                                        } else {
                                            throw "1 EX does not support this operands";
                                        };
                                    };
                                    code.push(opCode);
                                    p1.value = undefined;
                                    break;

                                default:
                                    throw "Invalid instruction: " + match[2];
                            }

                            if (instr !== 'TABLE' && instr!== 'BYTE') {
                                addLabel_dauph(opCode, address, p1, p2, lines[i]); //nk
                            }
                        }
                    } else {
                        // Check if line starts with a comment otherwise the line contains an error and can not be parsed
                        var line = lines[i].trim();
                        if (line !== "" && line.slice(0, 1) !== ";") {
                            throw "Syntax error";
                        }
                    }
                } catch (e) {
                    throw {error: e, line: i};
                }
            }

            if (debug) console.log('L-1229', code,labels, labels_dauph,constants);
            for (i = 0, l = code.length; i < l; i++) {
                if ((!angular.isNumber(code[i]) && !angular.isArray(code[i])) || (angular.isArray(code[i]) && !angular.isNumber(code[i][1]))) { //nk
                    if (code[i] in labels) {
                        
                        var add12bits = parseAddressValue(labels[code[i]]);
                        code[i-1] += add12bits[0];
                        code[i] = add12bits[1];

                    } else {

                        throw {error: "Undefined label: " + code[i] +" i:" + i.toString()};
                    }
                }
            }
        
            for (i in labels_dauph) {
                for (j = 0, l = labels_dauph[i].array.length; j < l; j++) {
                    if (!angular.isNumber(labels_dauph[i].array[j])){
                        // if (debug) console.log(labels_dauph[i].array[j])
                        var add12bits = parseAddressValue(labels[labels_dauph[i].array[j]]);
                        labels_dauph[i].array[j-1] += add12bits[0];
                        labels_dauph[i].array[j] = add12bits[1];
                    }
                }
            }

            if (debug) console.log('mapping:\n', mapping) // address - line code
            // if (debug) console.log(labels)  // nom - ??
            if (debug) console.log('labels_dauph:\n',labels_dauph)
            if (debug) console.log('code:\n',code)
            return {code: code, mapping: mapping, labels: labels, labels_dauph: labels_dauph};
        }
    };
}]);
;app.service('cpu', ['opcodes', 'memory', 'bus', 'constants', 'routines', function(opcodes, memory, bus, constants, routines) {
    var cpu = {
        step: function() {
            var self = this;
            var debug = false;

            if (self.fault === true) {
                throw "FAULT. Reset to continue.";
            }

            try {
                var checkGPR = function(reg) {
                    if (reg < 0 || reg >= self.gpr.length) {
                        throw "Invalid register: " + reg;
                    } else {
                        return reg;
                    }
                };

                var checkGPR_SP = function(reg) {
                    if (reg < 0 || reg >= 1 + self.gpr.length) {
                        throw "Invalid register: " + reg;
                    } else {
                        return reg;
                    }
                };

                var setGPR_SP = function(reg,value)
                {
                    if(reg >= 0 && reg < self.gpr.length) {
                        self.gpr[reg] = value;
                    } else if(reg == self.gpr.length) {
                        self.sp = value;

                        // Not likely to happen, since we always get here after checkOpertion().
                        if (self.sp < self.minSP) {
                            throw "Stack overflow";
                        } else if (self.sp > self.maxSP) {
                            throw "Stack underflow";
                        }
                    } else {
                        throw "Invalid register: " + reg;
                    }
                };

                var getGPR_SP = function(reg)
                {
                    if(reg >= 0 && reg < self.gpr.length) {
                        return self.gpr[reg];
                    } else if(reg == self.gpr.length) {
                        return self.sp;
                    } else {
                        throw "Invalid register: " + reg;
                    }
                };

                var checkOperation = function(value) {
                    var lim = 256
                    self.zero = false;
                    self.carry = false;
                    self.negative = false;

                    if (value >= lim) { // limite 8bit
                        if (debug) console.log('checkOperation', value, '>', lim)
                        self.carry = true;
                        value = value % lim;
                    }else if(value >= 128){ // 7ème bit à 1
                        self.negative = true;
                    } else if (value === 0) {
                        self.zero = true;
                    } else if (value < 0) {
                        if (value>=-128){
                            self.negative= true;     
                        }
                        self.carry = true
                        value = (lim - (-value) % lim)%lim;
                    }

                    return value;
                };

                var jump = function(newIP) {
                    if (newIP < 0 || newIP >= memory.data.length) {
                        throw "pc outside memory";
                    } else {
                        self.pc = newIP;
                    }
                };

                var push = function(value) {
                    memory.store(self.sp--, value);
                    if (self.sp < self.minSP) {
                        throw "Stack overflow";
                    }
                };

                var pop = function() {
                    var value = memory.load(++self.sp);
                    if (self.sp > self.maxSP) {
                        throw "Stack underflow";
                    }

                    return value;
                };


                var testBit = function(value, bit, option = null) {
                    var debug = false;
                    bit = bit % 8;
                    var test = (value >>> bit)%2;
                    self.zero = test==0;    // INVERSER DANS LE MANUEL (MAIS LE SIMULATEUR SE COMPORTE COMME CA BIT=1 -> ZERO=0 ET BIT=0 ->ZERO=1)
                    if (debug) console.log(value,test,bit, self.zero);
                    switch(option){
                        case 'set':
                            if (test==0){
                                value = value + 2**bit;
                            };
                            break;
                        case 'clr':
                            if (test==1){
                                value = value - 2**bit;
                            };
                            break;
                        case 'not':
                            if (test==0){
                                value = value + 2**bit;
                            }else{
                                value = value - 2**bit;
                            };
                            break;
                    }
                    if (debug) console.log(value,test,bit);
                    return value;
                };

                var address12bits = function(array) { //nk
                    var addressDec;
                    addressDec = array[0]*256 + array[1];
                    if (addressDec>32768){
                        addressDec -= 32768; // attention signed number
                        if (addressDec>=128){
                            addressDec = self.pc-256%addressDec;
                        }else{
                            addressDec +=self.pc
                        };
                    }else if(addressDec>16384){
                        addressDec -= 16384;
                        if (addressDec>=128){
                            addressDec = self.sp-256%addressDec;
                        }else{
                            addressDec +=self.sp
                        };
                    }else if(addressDec>12288){
                        addressDec -= 12288-getGPR_SP(2)-getGPR_SP(3);
                    }else if(addressDec>8192){
                        addressDec -= 8192-getGPR_SP(3);
                    }else if(addressDec>4096){
                        addressDec -= 4096-getGPR_SP(2);
                    } 
                    
                    return addressDec;
                };

                if (self.pc < 0 || self.pc >= memory.data.length) {
                    throw "Instruction pointer is outside of memory";
                }
                
                var regTo, regFrom, memFrom = [], memTo = [], number;
                var instr = memory.load(self.pc);
                if (debug) console.log('L899-cpu: (instr, pc)', instr, self.pc)
                switch(instr) {
                    case opcodes.HALT:
                        return false; // Abort step
                    case opcodes.MOVE_Y_TO_Y:
                    case opcodes.MOVE_Y_TO_X:
                    case opcodes.MOVE_Y_TO_B:
                    case opcodes.MOVE_Y_TO_A:
                        regFrom = 3;
                        regTo = checkGPR_SP(instr-opcodes.MOVE_Y_TO_A);
                        var carry = self.carry;
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regFrom)));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.MOVE_X_TO_Y:
                    case opcodes.MOVE_X_TO_X:
                    case opcodes.MOVE_X_TO_B:
                    case opcodes.MOVE_X_TO_A:
                        regFrom = 2;
                        regTo = checkGPR_SP(instr-opcodes.MOVE_X_TO_A);
                        var carry = self.carry;
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regFrom)));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.MOVE_B_TO_Y:
                    case opcodes.MOVE_B_TO_X:
                    case opcodes.MOVE_B_TO_B:
                    case opcodes.MOVE_B_TO_A:
                        regFrom = 1;
                        regTo = checkGPR_SP(instr-opcodes.MOVE_B_TO_A);
                        var carry = self.carry;
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regFrom)));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.MOVE_A_TO_Y:
                    case opcodes.MOVE_A_TO_X:
                    case opcodes.MOVE_A_TO_B:
                    case opcodes.MOVE_A_TO_A:
                        regFrom = 0;
                        regTo = checkGPR_SP(instr-opcodes.MOVE_A_TO_A);
                        var carry = self.carry;
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regFrom)));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.MOVE_NUMBER_TO_Y:
                    case opcodes.MOVE_NUMBER_TO_X:
                    case opcodes.MOVE_NUMBER_TO_B:
                    case opcodes.MOVE_NUMBER_TO_A:
                        regTo = checkGPR_SP(instr-opcodes.MOVE_NUMBER_TO_A);
                        number = memory.load(++self.pc);
                        var carry = self.carry;
                        setGPR_SP(regTo,checkOperation(number));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.MOVE_ADDRESS_TO_Y:
                    case opcodes.MOVE_ADDRESS_TO_X:
                    case opcodes.MOVE_ADDRESS_TO_B:
                    case opcodes.MOVE_ADDRESS_TO_A:
                        regTo = checkGPR_SP(instr-opcodes.MOVE_ADDRESS_TO_A);
                        var memFrom = [];
                        memFrom[0] = memory.load(++self.pc);
                        memFrom[1] = memory.load(++self.pc);
                        var carry = self.carry;
                        setGPR_SP(regTo,checkOperation(memory.load(address12bits(memFrom))));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.MOVE_Y_TO_ADDRESS:
                    case opcodes.MOVE_X_TO_ADDRESS:
                    case opcodes.MOVE_B_TO_ADDRESS:
                    case opcodes.MOVE_A_TO_ADDRESS:
                        regFrom = checkGPR_SP(instr-opcodes.MOVE_A_TO_ADDRESS);
                        var memTo = [];
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        var carry = self.carry;
                        memory.store(address12bits(memTo),checkOperation(getGPR_SP(regFrom)));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.MOVE_NUMBER_TO_ADDRESS:
                        number = memory.load(++self.pc);
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        var carry = self.carry;
                        memory.store(address12bits(memTo),checkOperation(number));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.MOVE_SP_NUMBER_TO_Y:
                    case opcodes.MOVE_SP_NUMBER_TO_X:
                    case opcodes.MOVE_SP_NUMBER_TO_B:
                    case opcodes.MOVE_SP_NUMBER_TO_A:
                        memFrom[0] = memory.load(++self.pc);
                        memFrom[1] = memory.load(++self.pc);
                        regTo = checkGPR_SP(instr-opcodes.MOVE_SP_NUMBER_TO_A);
                        var carry = self.carry;
                        setGPR_SP(regTo,checkOperation(memory.load(address12bits(memFrom))));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;

                    case opcodes.MOVE_Y_TO_SP_NUMBER:
                    case opcodes.MOVE_X_TO_SP_NUMBER:
                    case opcodes.MOVE_B_TO_SP_NUMBER:
                    case opcodes.MOVE_A_TO_SP_NUMBER:
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        regFrom = checkGPR_SP(instr-opcodes.MOVE_A_TO_SP_NUMBER);
                        var carry = self.carry;
                        memory.store(address12bits(memTo), checkOperation(regFrom))
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;  

                    case opcodes.ADD_Y_TO_Y:
                    case opcodes.ADD_Y_TO_X:
                    case opcodes.ADD_Y_TO_B:
                    case opcodes.ADD_Y_TO_A:
                        regFrom = 3;
                        regTo = checkGPR_SP(instr-opcodes.ADD_Y_TO_A);
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regTo) + getGPR_SP(regFrom)));
                        self.pc++;
                        break;
                    case opcodes.ADD_X_TO_Y:
                    case opcodes.ADD_X_TO_X:
                    case opcodes.ADD_X_TO_B:
                    case opcodes.ADD_X_TO_A:
                        regFrom = 2;
                        regTo = checkGPR_SP(instr-opcodes.ADD_X_TO_A);
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regTo) + getGPR_SP(regFrom)));
                        self.pc++;
                        break;
                    case opcodes.ADD_B_TO_Y:
                    case opcodes.ADD_B_TO_X:
                    case opcodes.ADD_B_TO_B:
                    case opcodes.ADD_B_TO_A:
                        regFrom = 1;
                        regTo = checkGPR_SP(instr-opcodes.ADD_B_TO_A);
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regTo) + getGPR_SP(regFrom)));
                        self.pc++;
                        break;    
                    case opcodes.ADD_A_TO_Y:
                    case opcodes.ADD_A_TO_X:
                    case opcodes.ADD_A_TO_B:
                    case opcodes.ADD_A_TO_A:
                        regFrom = 0;
                        regTo = checkGPR_SP(instr-opcodes.ADD_A_TO_A);
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regTo) + getGPR_SP(regFrom)));
                        self.pc++;
                        break;

                    case opcodes.SUB_Y_TO_Y:
                    case opcodes.SUB_Y_TO_X:
                    case opcodes.SUB_Y_TO_B:
                    case opcodes.SUB_Y_TO_A:
                        regFrom = 3;
                        regTo = checkGPR_SP(instr-opcodes.SUB_Y_TO_A);
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regTo) - getGPR_SP(regFrom)));
                        self.pc++;
                        break;
                    case opcodes.SUB_X_TO_Y:
                    case opcodes.SUB_X_TO_X:
                    case opcodes.SUB_X_TO_B:
                    case opcodes.SUB_X_TO_A:
                        regFrom = 2;
                        regTo = checkGPR_SP(instr-opcodes.SUB_X_TO_A);
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regTo) - getGPR_SP(regFrom)));
                        self.pc++;
                        break;
                    case opcodes.SUB_B_TO_Y:
                    case opcodes.SUB_B_TO_X:
                    case opcodes.SUB_B_TO_B:
                    case opcodes.SUB_B_TO_A:
                        regFrom = 1;
                        regTo = checkGPR_SP(instr-opcodes.SUB_B_TO_A);
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regTo) - getGPR_SP(regFrom)));
                        self.pc++;
                        break;    
                    case opcodes.SUB_A_TO_Y:
                    case opcodes.SUB_A_TO_X:
                    case opcodes.SUB_A_TO_B:
                    case opcodes.SUB_A_TO_A:
                        regFrom = 0;
                        regTo = checkGPR_SP(instr-opcodes.SUB_A_TO_A);
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regTo) - getGPR_SP(regFrom)));
                        self.pc++;
                        break;

                    case opcodes.ADD_NUMBER_TO_Y:
                    case opcodes.ADD_NUMBER_TO_X:
                    case opcodes.ADD_NUMBER_TO_B:
                    case opcodes.ADD_NUMBER_TO_A:
                        number = memory.load(++self.pc);
                        regTo = checkGPR_SP(instr-opcodes.ADD_NUMBER_TO_A);
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regTo) + number));
                        self.pc++;
                        break;
                    case opcodes.ADD_ADDRESS_TO_Y:
                    case opcodes.ADD_ADDRESS_TO_X:
                    case opcodes.ADD_ADDRESS_TO_B:
                    case opcodes.ADD_ADDRESS_TO_A:
                        memFrom[0] = memory.load(++self.pc);
                        memFrom[1] = memory.load(++self.pc);
                        regTo = checkGPR_SP(instr-opcodes.ADD_ADDRESS_TO_A);
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regTo) + memory.load(address12bits(memFrom))));
                        self.pc++;
                        break;
                    case opcodes.ADD_Y_TO_ADDRESS:
                    case opcodes.ADD_X_TO_ADDRESS:
                    case opcodes.ADD_B_TO_ADDRESS:
                    case opcodes.ADD_A_TO_ADDRESS:
                        regFrom = checkGPR_SP(instr-opcodes.ADD_A_TO_ADDRESS);
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        memory.store(address12bits(memTo),checkOperation(getGPR_SP(regFrom) + memory.load(address12bits(memTo))));
                        self.pc++;
                        break;
                    case opcodes.ADD_NUMBER_TO_ADDRESS:
                        number = memory.load(++self.pc);
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        memory.store(address12bits(memTo),checkOperation(number + memory.load(address12bits(memTo))));
                        self.pc++;
                        break;

                    case opcodes.SUB_NUMBER_TO_Y:
                    case opcodes.SUB_NUMBER_TO_X:
                    case opcodes.SUB_NUMBER_TO_B:
                    case opcodes.SUB_NUMBER_TO_A:
                        number = memory.load(++self.pc);
                        regTo = checkGPR_SP(instr-opcodes.SUB_NUMBER_TO_A);
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regTo) - number));
                        self.pc++;
                        break;
                    case opcodes.SUB_ADDRESS_TO_Y:
                    case opcodes.SUB_ADDRESS_TO_X:
                    case opcodes.SUB_ADDRESS_TO_B:
                    case opcodes.SUB_ADDRESS_TO_A:
                        memFrom[0] = memory.load(++self.pc);
                        memFrom[1] = memory.load(++self.pc);
                        regTo = checkGPR_SP(instr-opcodes.SUB_ADDRESS_TO_A);
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regTo) - memory.load(address12bits(memFrom))));
                        self.pc++;
                        break;
                    case opcodes.SUB_Y_TO_ADDRESS:
                    case opcodes.SUB_X_TO_ADDRESS:
                    case opcodes.SUB_B_TO_ADDRESS:
                    case opcodes.SUB_A_TO_ADDRESS:
                        regFrom = checkGPR_SP(instr-opcodes.SUB_A_TO_ADDRESS);
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        memory.store(address12bits(memTo),checkOperation(memory.load(address12bits(memTo))-getGPR_SP(regFrom)));
                        self.pc++;
                        break;
                    case opcodes.SUB_NUMBER_TO_ADDRESS:
                        number = memory.load(++self.pc);
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        memory.store(address12bits(memTo),checkOperation(memory.load(address12bits(memTo))-number));
                        self.pc++;
                        break;
                    case opcodes.ADD_NUMBER_TO_SP:
                        number = memory.load(++self.pc);
                        self.sp = self.sp + number;
                        self.pc++;
                        break;
                    case opcodes.SUB_NUMBER_TO_SP:
                        number = memory.load(++self.pc);
                        self.sp = self.sp - number;
                        self.pc++;
                        break;
                    case opcodes.INC_Y:
                    case opcodes.INC_X:
                    case opcodes.INC_B:
                    case opcodes.INC_A:
                        regTo = checkGPR_SP(instr-opcodes.INC_A);
                        var carry = self.carry;
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regTo) + 1));
                        self.carry = carry;
                        self.pc++;
                        break;
                    case opcodes.INC_ADDRESS:
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        var carry = self.carry;
                        memory.store(address12bits(memTo),checkOperation(memory.load(address12bits(memTo))+1));
                        self.carry = carry;
                        self.pc++;
                        break;
                    case opcodes.DEC_Y:
                    case opcodes.DEC_X:
                    case opcodes.DEC_B:
                    case opcodes.DEC_A:
                        regTo = checkGPR_SP(instr-opcodes.DEC_A);
                        var carry = self.carry;
                        setGPR_SP(regTo,checkOperation(getGPR_SP(regTo) - 1));
                        self.carry = carry;
                        self.pc++;
                        break;
                    case opcodes.DEC_ADDRESS:
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        var carry = self.carry;
                        memory.store(address12bits(memTo),checkOperation(memory.load(address12bits(memTo)) - 1));
                        self.carry = carry;
                        self.pc++;
                        break;

                    case opcodes.COMP_Y_TO_Y:
                    case opcodes.COMP_Y_TO_X:
                    case opcodes.COMP_Y_TO_B:
                    case opcodes.COMP_Y_TO_A:
                        regTo = checkGPR_SP(instr-opcodes.COMP_Y_TO_A);
                        regFrom = 3;
                        checkOperation(getGPR_SP(regTo) - getGPR_SP(regFrom));
                        self.pc++;
                        break;
                    case opcodes.COMP_X_TO_Y:
                    case opcodes.COMP_X_TO_X:
                    case opcodes.COMP_X_TO_B:
                    case opcodes.COMP_X_TO_A:
                        regTo = checkGPR_SP(instr-opcodes.COMP_X_TO_A);
                        regFrom = 2;
                        checkOperation(getGPR_SP(regTo) - getGPR_SP(regFrom));
                        self.pc++;
                        break;
                    case opcodes.COMP_B_TO_Y:
                    case opcodes.COMP_B_TO_X:
                    case opcodes.COMP_B_TO_B:
                    case opcodes.COMP_B_TO_A:
                        regTo = checkGPR_SP(instr-opcodes.COMP_B_TO_A);
                        regFrom = 1;
                        checkOperation(getGPR_SP(regTo) - getGPR_SP(regFrom));
                        self.pc++;
                        break;
                    case opcodes.COMP_A_TO_Y:
                    case opcodes.COMP_A_TO_X:
                    case opcodes.COMP_A_TO_B:
                    case opcodes.COMP_A_TO_A:
                        regTo = checkGPR_SP(instr-opcodes.COMP_A_TO_A);
                        regFrom = 0;
                        checkOperation(getGPR_SP(regTo) - getGPR_SP(regFrom));
                        self.pc++;
                        break;
                    case opcodes.COMP_NUMBER_TO_Y:
                    case opcodes.COMP_NUMBER_TO_X:
                    case opcodes.COMP_NUMBER_TO_B:
                    case opcodes.COMP_NUMBER_TO_A:
                        regTo = checkGPR_SP(instr-opcodes.COMP_NUMBER_TO_A);
                        number = memory.load(++self.pc);
                        checkOperation(getGPR_SP(regTo) - number);
                        self.pc++;
                        break;
                        
                    case opcodes.COMP_ADDRESS_TO_Y:
                    case opcodes.COMP_ADDRESS_TO_X:
                    case opcodes.COMP_ADDRESS_TO_B:
                    case opcodes.COMP_ADDRESS_TO_A:
                        regTo = checkGPR_SP(instr-opcodes.COMP_ADDRESS_TO_A);
                        var memFrom = []
                        memFrom[0] = memory.load(++self.pc);
                        memFrom[1] = memory.load(++self.pc);
                        checkOperation(getGPR_SP(regTo) -  memory.load(address12bits(memFrom)));
                        self.pc++;
                        break;
                        
                    case opcodes.COMP_NUMBER_TO_ADDRESS:
                        number = memory.load(++self.pc);
                        var memTo = []
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        checkOperation(memory.load(address12bits(memTo))-number);
                        self.pc++;
                        break;

                    case opcodes.JUMP_ADDRESS:
                        var memTo = []
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        jump(address12bits(memTo));
                        break;
                    case opcodes.JUMP_EQ_ADDRESS:
                    case opcodes.JUMP_ZS_ADDRESS:
                        var memTo = []
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        if (self.zero) {
                            jump(address12bits(memTo));
                        } else {
                            self.pc++;
                        }
                        break;
                    case opcodes.JUMP_NE_ADDRESS:
                    case opcodes.JUMP_ZC_ADDRESS:
                        var memTo = []
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        if (!self.zero) {
                            jump(address12bits(memTo));
                        } else {
                            self.pc++;
                        }
                        break;              
                    
                    case opcodes.JUMP_LS_ADDRESS:
                        var memTo = []
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        if (self.carry || self.zero) {
                            jump(address12bits(memTo));
                        } else {
                            self.pc++;
                        }
                        break;                  
                    case opcodes.JUMP_HI_ADDRESS: 
                        var memTo = [];
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        if (!self.zero && !self.carry) { 
                            jump(address12bits(memTo));
                        } else {
                            self.pc++;
                        }
                        break;
                        
                    case opcodes.JUMP_CC_ADDRESS:
                        var memTo = []
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        if (!self.carry) {
                            jump(address12bits(memTo));
                        } else {
                            self.pc++;
                        }
                        break;
                    case opcodes.JUMP_LO_ADDRESS:
                        var memTo = [];
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        if (self.carry) {
                            jump(address12bits(memTo));
                        } else {
                            self.pc++;
                        }
                        break;
                    case opcodes.JUMP_CS_ADDRESS:
                        var memTo = [];
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        if (self.carry) {
                            jump(address12bits(memTo));
                        } else {
                            self.pc++;
                        }
                        break;
                    case opcodes.JUMP_NS_ADDRESS:
                        var memTo = []
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        if (self.negative) {
                            jump(address12bits(memTo));
                        } else {
                            self.pc++;
                        }
                        break;                 
                    case opcodes.JUMP_HS_ADDRESS: 
                        var memTo = [];
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        if (!self.carry) { 
                            jump(address12bits(memTo));
                        } else {
                            self.pc++;
                        }
                        break;
                    case opcodes.JUMP_NC_ADDRESS:
                        var memTo = []
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        if (!self.negative) {
                            jump(address12bits(memTo));
                        } else {
                            self.pc++;
                        }
                        break;                 
                        
                    case opcodes.PUSH_Y:
                    case opcodes.PUSH_X:
                    case opcodes.PUSH_B:
                    case opcodes.PUSH_A:
                        regFrom = checkGPR(instr-opcodes.PUSH_A);
                        push(getGPR_SP(regFrom));
                        self.pc++;
                        break;
                    case opcodes.POP_Y:
                    case opcodes.POP_X:
                    case opcodes.POP_B:
                    case opcodes.POP_A:
                        regTo = checkGPR(instr-opcodes.POP_A);
                        setGPR_SP(regTo, checkOperation(pop()));
                        self.pc++;
                        break;

                    // case opcodes.PUSH_F:
                    // case opcodes.POP_F:

                    case opcodes.CALL_ADDRESS:
                        var memTo = [];
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        push(self.pc+1);
                        jump(address12bits(memTo));
                        break;
                    case opcodes.CALL_ROUTINE:
                        var memTo = [];
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);
                        var result = routines.call(address12bits(memTo),getGPR_SP(0),getGPR_SP(1),getGPR_SP(2),getGPR_SP(3));
                        if (result!=undefined){
                            self[result[0]] = result[1];
                        }
                        self.pc++
                        break;
                    case opcodes.RET:
                        jump(pop());
                        break;
                    

                    case opcodes.AND_A_TO_B: // & binary AND
                    case opcodes.AND_B_TO_A:
                        regFrom = checkGPR(instr-opcodes.AND_A_TO_B); // 1er opérande
                        regTo = checkGPR(1-regFrom); // 2eme opérande
                        var carry = self.carry;
                        setGPR_SP(regTo, checkOperation(getGPR_SP(regTo) & getGPR_SP(regFrom)));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.AND_NUMBER_TO_Y:
                    case opcodes.AND_NUMBER_TO_X:
                    case opcodes.AND_NUMBER_TO_B:
                    case opcodes.AND_NUMBER_TO_A:
                        regTo = checkGPR(instr-opcodes.AND_NUMBER_TO_A);
                        number = memory.load(++self.pc);
                        var carry = self.carry;
                        setGPR_SP(regTo, checkOperation(getGPR_SP(regTo) & number));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.AND_ADDRESS_TO_A:
                    case opcodes.AND_ADDRESS_TO_B:
                        regTo = checkGPR(instr-opcodes.AND_ADDRESS_TO_A);
                        memFrom[0] = memory.load(++self.pc);
                        memFrom[1] = memory.load(++self.pc);  
                        var carry = self.carry;
                        setGPR_SP(regTo, checkOperation(getGPR_SP(regTo) & memory.load(address12bits(memFrom))));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.AND_A_TO_ADDRESS:
                    case opcodes.AND_B_TO_ADDRESS:
                        regFrom = checkGPR(instr-opcodes.AND_A_TO_ADDRESS);
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);  
                        var carry = self.carry;
                        memory.store(address12bits(memTo), checkOperation(getGPR_SP(regFrom) & memory.load(address12bits(memTo))));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;

                    case opcodes.OR_A_TO_B: // | binary OR
                    case opcodes.OR_B_TO_A:
                        regFrom = checkGPR(instr-opcodes.OR_A_TO_B); // 1er opérande
                        regTo = checkGPR(1-regFrom); // 2eme opérande
                        var carry = self.carry;
                        setGPR_SP(regTo, checkOperation(getGPR_SP(regTo) | getGPR_SP(regFrom)));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.OR_NUMBER_TO_Y:
                    case opcodes.OR_NUMBER_TO_X:
                    case opcodes.OR_NUMBER_TO_B:
                    case opcodes.OR_NUMBER_TO_A:
                        regTo = checkGPR(instr-opcodes.OR_NUMBER_TO_A);
                        number = memory.load(++self.pc);
                        var carry = self.carry;
                        setGPR_SP(regTo, checkOperation(getGPR_SP(regTo) | number));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.OR_ADDRESS_TO_A:
                    case opcodes.OR_ADDRESS_TO_B:
                        regTo = checkGPR(instr-opcodes.OR_ADDRESS_TO_A);
                        memFrom[0] = memory.load(++self.pc);
                        memFrom[1] = memory.load(++self.pc);  
                        var carry = self.carry;
                        setGPR_SP(regTo, checkOperation(getGPR_SP(regTo) | memory.load(address12bits(memFrom))));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.OR_A_TO_ADDRESS:
                    case opcodes.OR_B_TO_ADDRESS:
                        regFrom = checkGPR(instr-opcodes.OR_A_TO_ADDRESS);
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);  
                        var carry = self.carry;
                        memory.store(address12bits(memTo), checkOperation(getGPR_SP(regFrom) | memory.load(address12bits(memTo))));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;

                    case opcodes.XOR_A_TO_B: // ^ binary XOR
                    case opcodes.XOR_B_TO_A:
                        regFrom = checkGPR(instr-opcodes.XOR_A_TO_B); // 1er opérande
                        regTo = checkGPR(1-regFrom); // 2eme opérande
                        var carry = self.carry;
                        setGPR_SP(regTo, checkOperation(getGPR_SP(regTo) ^ getGPR_SP(regFrom)));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.XOR_NUMBER_TO_Y:
                    case opcodes.XOR_NUMBER_TO_X:
                    case opcodes.XOR_NUMBER_TO_B:
                    case opcodes.XOR_NUMBER_TO_A:
                        regTo = checkGPR(instr-opcodes.XOR_NUMBER_TO_A);
                        number = memory.load(++self.pc);
                        var carry = self.carry;
                        setGPR_SP(regTo, checkOperation(getGPR_SP(regTo) ^ number));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.XOR_ADDRESS_TO_A:
                    case opcodes.XOR_ADDRESS_TO_B:
                        regTo = checkGPR(instr-opcodes.XOR_ADDRESS_TO_A);
                        memFrom[0] = memory.load(++self.pc);
                        memFrom[1] = memory.load(++self.pc);  
                        var carry = self.carry;
                        setGPR_SP(regTo, checkOperation(getGPR_SP(regTo) ^ memory.load(address12bits(memFrom))));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.XOR_A_TO_ADDRESS:
                    case opcodes.XOR_B_TO_ADDRESS:
                        regFrom = checkGPR(instr-opcodes.XOR_A_TO_ADDRESS);
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);  
                        var carry = self.carry;
                        memory.store(address12bits(memTo), checkOperation(getGPR_SP(regFrom) ^ memory.load(address12bits(memTo))));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;

                    case opcodes.NOT_Y:
                    case opcodes.NOT_X:
                    case opcodes.NOT_B:
                    case opcodes.NOT_A:
                        regTo = checkGPR(instr-opcodes.NOT_A);
                        var carry = self.carry;
                        setGPR_SP(regTo, checkOperation(~getGPR_SP(regTo)));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.NOT_ADDRESS:
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);  
                        var carry = self.carry;
                        memory.store(address12bits(memTo), checkOperation(~memory.load(address12bits(memTo))));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.CLR_Y:
                    case opcodes.CLR_X:
                    case opcodes.CLR_B:
                    case opcodes.CLR_A:
                        regTo = checkGPR(instr-opcodes.CLR_A);
                        var carry = self.carry;
                        setGPR_SP(regTo, checkOperation(0));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    case opcodes.CLR_ADDRESS:
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc);  
                        var carry = self.carry;
                        memory.store(address12bits(memTo), checkOperation(0));
                        self.carry = carry; //réiniatlise le carry
                        self.pc++;
                        break;
                    
                    case opcodes.RL_Y:
                    case opcodes.RL_X:
                    case opcodes.RL_B:
                    case opcodes.RL_A:
                        regTo = checkGPR(instr-opcodes.RL_A);
                        var valTxt = ("00000000"+getGPR_SP(regTo).toString(2));
                        valTxt = valTxt.substring(valTxt.length-8);
                        console.log('RR1:', valTxt);
                        valTxt = valTxt.slice(1)+[valTxt[0]]
                        console.log('RR2:',valTxt);
                        setGPR_SP(regTo, checkOperation(parseInt(valTxt,2)))
                        
                        self.pc++;
                        break;
                    case opcodes.RL_ADDRESS:
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc); 
                        var valTxt = ("00000000"+memory.load(address12bits(memTo)).toString(2));
                        valTxt = valTxt.substring(valTxt.length-8);
                        console.log('RR1:', valTxt);
                        valTxt = valTxt.slice(1)+[valTxt[0]]
                        console.log('RR2:',valTxt);
                        memory.store(address12bits(memTo), checkOperation(parseInt(valTxt,2)));
                        self.pc++;
                        break;
                    
                    case opcodes.RR_Y:
                    case opcodes.RR_X:
                    case opcodes.RR_B:
                    case opcodes.RR_A:
                        regTo = checkGPR(instr-opcodes.RR_A);
                        var valTxt = ("00000000"+getGPR_SP(regTo).toString(2));
                        valTxt = valTxt.substring(valTxt.length-8);
                        console.log('RR1:', valTxt);
                        valTxt = [valTxt[7]]+valTxt.slice(0,7)
                        console.log('RR2:',valTxt);
                        setGPR_SP(regTo, checkOperation(parseInt(valTxt,2)));
                        
                        self.pc++;
                        break;
                    case opcodes.RR_ADDRESS:
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc); 
                        var valTxt = ("00000000"+memory.load(address12bits(memTo)).toString(2));
                        valTxt = valTxt.substring(valTxt.length-8);
                        console.log('RR1:', valTxt);
                        valTxt = [valTxt[7]]+valTxt.slice(0,7)
                        console.log('RR2:',valTxt);
                        memory.store(address12bits(memTo), checkOperation(parseInt(valTxt,2)));
                        self.pc++;
                        break;

                    case opcodes.RLC_Y:
                    case opcodes.RLC_X:
                    case opcodes.RLC_B:
                    case opcodes.RLC_A:
                        regTo = checkGPR(instr-opcodes.RLC_A);
                        
                        var valTxt = ("00000000"+ getGPR_SP(regTo).toString(2));
                        valTxt = (+self.carry).toString(2) + valTxt.substring(valTxt.length-8);
                        
                        var carry = parseInt(valTxt[1],2)==1;
                        valTxt = valTxt.slice(2)+[valTxt[0]];
                        
                        setGPR_SP(regTo,checkOperation(parseInt(valTxt,2)));
                        self.carry = carry;
                        console.log(self)
                        self.pc++;
                        break;
                    case opcodes.RLC_ADDRESS:
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc); 
                        var valTxt = ("00000000"+ memory.load(address12bits(memTo)).toString(2));
                        valTxt = (+self.carry).toString(2) + valTxt.substring(valTxt.length-8);
                        var carry = parseInt(valTxt[1],2)==1;
                        valTxt = valTxt.slice(2)+[valTxt[0]];
                        memory.store(address12bits(memTo), checkOperation(parseInt(valTxt,2)));
                        self.carry = carry;
                        self.pc++;
                        break;
                        
                    case opcodes.RRC_Y:
                    case opcodes.RRC_X:
                    case opcodes.RRC_B:
                    case opcodes.RRC_A:
                        regTo = checkGPR(instr-opcodes.RRC_A);
                        var valTxt = ("00000000" + getGPR_SP(regTo).toString(2));
                        valTxt = (+self.carry).toString(2) + valTxt.substring(valTxt.length-8);
                        var carry = parseInt(valTxt[8],2)==1;
                        valTxt = valTxt.slice(0,8)
                        setGPR_SP(regTo, checkOperation(parseInt(valTxt,2)));
                        self.carry = carry;
                        self.pc++;
                        break;
                    case opcodes.RRC_ADDRESS:
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc); 
                        var valTxt = ("00000000"+memory.load(address12bits(memTo)).toString(2));
                        valTxt = (+self.carry).toString(2) + valTxt.substring(valTxt.length-8);
                        var carry = parseInt(valTxt[8],2)==1;
                        valTxt = valTxt.slice(0,8)
                        memory.store(address12bits(memTo), checkOperation(parseInt(valTxt,2)));  
                        self.carry = carry;
                        self.pc++;
                        break;

                    case opcodes.TEST_A_NUMBER:
                    case opcodes.TEST_B_NUMBER:
                        regTo = checkGPR(instr-opcodes.TEST_A_NUMBER);
                        number = memory.load(++self.pc);
                        testBit(getGPR_SP(regTo), number, null);
                        self.pc++;
                        break;
                    case opcodes.TEST_ADDRESS_NUMBER:
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc); 
                        number = memory.load(++self.pc);
                        testBit(memory.load(address12bits(memTo)), number, null);
                        self.pc++;
                        break;
                    case opcodes.TEST_A_B:
                    case opcodes.TEST_B_A:
                        regFrom = checkGPR(instr-opcodes.TEST_B_A);
                        regTo = checkGPR(1-regFrom);
                        testBit(getGPR_SP(regTo), getGPR_SP(regFrom), null);
                        self.pc++;
                        break;
                    case opcodes.TEST_ADDRESS_A:
                    case opcodes.TEST_ADDRESS_B:
                        regFrom = checkGPR(instr-opcodes.TEST_ADDRESS_A);
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc); 
                        testBit(memory.load(address12bits(memTo)), getGPR_SP(regFrom), null);
                        self.pc++;
                        break;
                    case opcodes.TSET_A_NUMBER:
                    case opcodes.TSET_B_NUMBER:
                        regTo = checkGPR(instr-opcodes.TSET_A_NUMBER);
                        number = memory.load(++self.pc);
                        setGPR_SP(regTo,testBit(getGPR_SP(regTo), number, 'set'));
                        self.pc++;
                        break;
                    case opcodes.TSET_ADDRESS_NUMBER:
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc); 
                        number = memory.load(++self.pc);
                        memory.store(address12bits(memTo), testBit(memory.load(address12bits(memTo)), number, 'set'));
                        self.pc++;
                        break;
                    case opcodes.TSET_A_B:
                    case opcodes.TSET_B_A:
                        regFrom = checkGPR(instr-opcodes.TSET_B_A);
                        regTo = checkGPR(1-regFrom);
                        setGPR_SP(regTo, testBit(getGPR_SP(regTo), getGPR_SP(regFrom), 'set'));
                        self.pc++;
                        break;
                    case opcodes.TSET_ADDRESS_A:
                    case opcodes.TSET_ADDRESS_B:
                        regFrom = checkGPR(instr-opcodes.TSET_ADDRESS_A);
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc); 
                        memory.store(address12bits(memTo), testBit(memory.load(address12bits(memTo)), getGPR_SP(regFrom), 'set'));
                        self.pc++;
                        break;
                    case opcodes.TCLR_A_NUMBER:
                    case opcodes.TCLR_B_NUMBER:
                        regTo = checkGPR(instr-opcodes.TCLR_A_NUMBER);
                        number = memory.load(++self.pc);
                        setGPR_SP(regTo, testBit(getGPR_SP(regTo), number, 'clr'));
                        self.pc++;
                        break;
                    case opcodes.TCLR_ADDRESS_NUMBER:
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc); 
                        number = memory.load(++self.pc);
                        memory.store(address12bits(memTo), testBit(memory.load(address12bits(memTo)), number, 'clr'));
                        self.pc++;
                        break;
                    case opcodes.TCLR_A_B:
                    case opcodes.TCLR_B_A:
                        regFrom = checkGPR(instr-opcodes.TCLR_B_A);
                        regTo = checkGPR(1-regFrom);
                        setGPR_SP(regTo, testBit(getGPR_SP(regTo), getGPR_SP(regFrom), 'clr'));
                        self.pc++;
                        break;
                    case opcodes.TCLR_ADDRESS_A:
                    case opcodes.TCLR_ADDRESS_B:
                        regFrom = checkGPR(instr-opcodes.TCLR_ADDRESS_A);
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc); 
                        memory.store(address12bits(memTo), testBit(memory.load(address12bits(memTo)), getGPR_SP(regFrom), 'clr'));
                        self.pc++;
                        break;
                    case opcodes.TNOT_A_NUMBER:
                    case opcodes.TNOT_B_NUMBER:
                        regTo = checkGPR(instr-opcodes.TNOT_A_NUMBER);
                        number = memory.load(++self.pc);
                        setGPR_SP(regTo, testBit(getGPR_SP(regTo), number, 'not'));
                        self.pc++;
                        break;
                    case opcodes.TNOT_ADDRESS_NUMBER:
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc); 
                        number = memory.load(++self.pc);
                        memory.store(address12bits(memTo), testBit(memory.load(address12bits(memTo)), number, 'not'));
                        self.pc++;
                        break;
                    case opcodes.TNOT_A_B:
                    case opcodes.TNOT_B_A:
                        regFrom = checkGPR(instr-opcodes.TNOT_B_A);
                        regTo = checkGPR(1-regFrom);
                        setGPR_SP(regTo, testBit(getGPR_SP(regTo), getGPR_SP(regFrom), 'not'));
                        self.pc++;
                        break;
                    case opcodes.TNOT_ADDRESS_A:
                    case opcodes.TNOT_ADDRESS_B:
                        regFrom = checkGPR(instr-opcodes.TNOT_ADDRESS_A);
                        memTo[0] = memory.load(++self.pc);
                        memTo[1] = memory.load(++self.pc); 
                        memory.store(address12bits(memTo), testBit(memory.load(address12bits(memTo)), getGPR_SP(regFrom), 'not'));
                        self.pc++;
                        break;
                    case opcodes.SETC:
                        self.carry = true;
                        self.pc++;
                        break;
                    case opcodes.CLRC:
                        self.carry = false;
                        self.pc++;
                        break;
                    case opcodes.NOTC:
                        self.carry = !self.carry;
                        self.pc++;
                        break;

                    case opcodes.EX_A_WITH_B:
                    case opcodes.EX_X_WITH_Y:
                        regFrom = checkGPR(instr-opcodes.EX_A_WITH_B)*2;
                        regTo = checkGPR(1+regFrom);
                        var tmp = getGPR_SP(regFrom);
                        setGPR_SP(regFrom, getGPR_SP(regTo));
                        setGPR_SP(regTo,tmp);
                        self.pc++;
                        break;
                    case opcodes.SWAP_B:
                    case opcodes.SWAP_A:
                        regFrom = checkGPR(instr-opcodes.SWAP_A);
                        var val1 = getGPR_SP(regFrom)%(2**4);
                        var val2 = (getGPR_SP(regFrom)>>4)%(2**4);
                        setGPR_SP(regFrom,val2 + val1*(2**4));
                        self.pc++;
                        break;
                    case opcodes.NOP:
                        self.pc++;
                        break;

                    default:
                        throw "Invalid op code: " + instr;
                }
                bus.update(self.pc); //NK
                return true;
            } catch(e) {
                self.fault = true;
                throw e;
            }
        },
        reset: function() {
            var self = this;
            self.maxSP = constants._KEYBOARD.value-1; // NK
            self.minSP = 0;

            self.gpr = [0, 0, 0, 0];
            self.sp = self.maxSP;
            self.pc = 0;
            self.zero = false;
            self.carry = false;
            self.fault = false;
            self.negative = false;
        }
    };

    cpu.reset();
    return cpu;
}]);
;app.service('memory', ['constants', function (constants) {
    var memory = {
        data: Array(constants.MEMOMRYSIZE.value),
        lastAccess: -1,
        load: function (address) {
            var self = this;

            if (address < 0 || address >= self.data.length) {
                throw "load: Memory access violation at " + address;
            }

            self.lastAccess = address;
            return self.data[address];
        },
        store: function (address, value) {
            var self = this;

            if (address < 0 || address >= self.data.length) {
                throw "store: Memory access violation at " + address;
            }

            self.lastAccess = address;
            self.data[address] = value;
        },
        reset: function () {
            var self = this;
            self.data=Array(constants.MEMOMRYSIZE.value),
            self.lastAccess = -1;
            for (var i = 0, l = self.data.length; i < l; i++) {
                self.data[i] = 0;
            }
            
        }
    };

    memory.reset();
    return memory;
}]);
;app.service('routines', ['memory','constants', function (memory, constants) {
    var routines = {
        call: function (routineCode, A, B, X, Y) {
            var self = this;
            var debug = false;

            var WaitSec = function(A){
                console.log("_Waitsec n'est pas implémenté")
                // console.log('WaitSec',A*500)
                // setTimeout(function(){console.log('wait',500*A,'s')}, 500*A);
            };
            // var WaitKey = function(){
            //     console.log('WaitKey')
            // };
            var DisplayBinaryDigit = function(A, B){
                B = B%4;
                memory.store(constants._DIGIT0.value+B, A);
            };
            var DisplayHexaDigit = function(A,B){
                if (debug) console.log('DisplayHexaDigit', A.toString(16), charToDigit(A.toString(16)))
                B = B%4;
                memory.store(constants._DIGIT0.value+B, charToDigit(A.toString(16).toUpperCase()));
            };
            var DisplayHexaByte = function(A,B){
                if (debug) console.log('DisplayHexaByte')
                B = B%3;
                var digit = A.toString(16).toUpperCase();
                if (digit.length<2){
                    digit = '0'+digit;
                }
                memory.store(constants._DIGIT0.value+B, charToDigit(digit[0]));
                memory.store(constants._DIGIT0.value+B+1, charToDigit(digit[1]));
            };
            var DisplayCharDigit = function(A, B){
                B = B%4;
                var digit = charToDigit(String.fromCharCode(A));
                if (digit != undefined){
                    memory.store(constants._DIGIT0.value+B, digit);
                }else{
                    throw "character not supported on digit display" + String.fromCharCode(A)
                }
            };

            var charToDigit = function(c){
                var digitConv = {'a': 111, 'b': 94,'c':60,'d':79,'e':125, 'f':120, 'g':62, 'h':90, 'i':2, 'j':7, 'k':0, 'l': 28, 'm':0,  'n':74, 'o':78, 'p': 121, 'q':115, 'r':72, 's':118, 't':88, 'u':14, 'v':14, 'w':0, 'x':0,'y':83,'z':109,
                                'A':123, 'B': 94, 'C':60, 'D':79, 'E':124, 'F':120, 'G':62, 'H':91, 'I':3, 'J':7, 'K':0, 'L': 28, 'M':0, 'N':74, 'O':78, 'P': 121, 'Q':63, 'R':72, 'S':118, 'T': 56, 'U':31, 'v':31, 'W':0, 'x':0, 'Y':83,'Z':109,
                                '0':63, '1':3, '2':108, '3':103, '4':83, '5':118, '6':111, '7':35, '8':127, '9':119,
                            };
                var value = digitConv[c];
                return value;
            };
            var ClearScreen = function(){
                for (i=constants._ASCII.value; i<constants.MEMOMRYSIZE.value;i++){
                    memory.store(i,0);
                }
            };
            var SetPixel = function(X,Y){
                if (debug) console.log('SetPixel')
                X = X%constants._BITMAPWIDTH.value;
                Y =Y%constants._BITMAPHEIGHT.value;
                x_byte= ~~(X/8)
                x_bit= 7-X%8;
                var memTo = constants._BITMAP.value+x_byte+Y*(constants._BITMAPWIDTH.value/8);
                var value = memory.load(memTo);
                var test = (value >>> x_bit)%2;

                if (test==0){
                    value = value + 2**x_bit;
                };
                memory.store(memTo,value);

            };
            var ClrPixel = function(X,Y){
                if (debug) console.log('ClrPixel')
                X = X%constants._BITMAPWIDTH.value;
                Y =Y%constants._BITMAPHEIGHT.value;
                x_byte= ~~(X/8)
                x_bit= 7-X%8;
                var memTo = constants._BITMAP.value+x_byte+Y*(constants._BITMAPWIDTH.value/8);
                var value = memory.load(memTo);
                var test = (value >>> x_bit)%2;

                if (test==1){
                    value = value - 2**x_bit;
                };
                memory.store(memTo,value);
            };
            var NotPixel = function(X,Y){
                if (debug) console.log('NotPixel')
                X = X%constants._BITMAPWIDTH.value;
                Y =Y%constants._BITMAPHEIGHT.value;
                x_byte= ~~(X/8)
                x_bit= 7-X%8;
                var memTo = constants._BITMAP.value+x_byte+Y*(constants._BITMAPWIDTH.value/8);
                var value = memory.load(memTo);
                var test = (value >>> x_bit)%2;

                if (test==0){
                    value = value + 2**x_bit;
                }else{
                    value = value - 2**x_bit;
                };
                memory.store(memTo,value);
            };
            var TestPixel = function(X,Y){
                if (debug) console.log('TestPixel')
                X = X%constants._BITMAPWIDTH.value;
                Y =Y%constants._BITMAPHEIGHT.value;
                x_byte= ~~(X/8)
                x_bit= 7-X%8;
                var memTo = constants._BITMAP.value+x_byte+Y*(constants._BITMAPWIDTH.value/8);
                var value = memory.load(memTo);
                var test = (value >>> x_bit)%2;

                return !test;
            };
            var DrawChar = function(A,X,Y){
                if (debug) console.log('DrawChar')
                var digit = String.fromCharCode(A);
                var pixels = charToPixel(digit)
                X = X %8;
                Y = Y%5;
                x_byte = ~~(X/2);
                if (X%2==0){
                    x_bits = [6,5,4];
                }else{
                    x_bits = [2,1,0];
                }
                y_line = Y*6;
                if (debug) console.log(pixels,x_byte,x_bits,y_line)
                draw(pixels,x_byte,x_bits,y_line);

            };
            var DrawHexaDigit = function(A,X,Y){
                if (debug) console.log('DrawHexaDigit')
                var digit = A.toString(16).toUpperCase();
                var pixels = charToPixel(digit);
                X = X %8;
                Y = Y%5;
                x_byte = ~~(X/2);
                if (X%2==0){
                    x_bits = [6,5,4];
                }else{
                    x_bits = [2,1,0];
                }
                y_line = Y*6;
                if (debug) console.log(pixels,x_byte,x_bits,y_line)
                draw(pixels,x_byte,x_bits,y_line);
            };
            var DrawHexaByte = function(A,X,Y){
                if (debug) console.log('DrawHexaByte')
                var digit = A.toString(16).toUpperCase();
                if (digit.length<2){
                    digit = '0'+digit;
                }
                for (i=0; i<2; i++){
                    var pixels = charToPixel(digit[i]);
                    X = (X+i) %8;
                    Y = Y%5;
                    x_byte = ~~(X/2);
                    if (X%2==0){
                        x_bits = [6,5,4];
                    }else{
                        x_bits = [2,1,0];
                    }
                    y_line = Y*6;
                    if (debug) console.log(pixels,x_byte,x_bits,y_line)
                    draw(pixels,x_byte,x_bits,y_line);
                };

            };
            var draw = function(pixelmap,xByte,xbits,y){
                for (var j=0; j<5; j++){
                    var memTo = constants._BITMAP.value+xByte+(y+j)*(constants._BITMAPWIDTH.value/8);
                    var value = memory.load(memTo);
                    for (var i=0; i<3; i++){
                        
                        var test = (value >>> xbits[i])%2;
                        if (test==0 && pixelmap[j][i]==1){
                            value = value + 2**xbits[i];
                        }else if(test==1 && pixelmap[j][i]==0){
                            value = value - 2**xbits[i];
                        };
                    };
                    if (debug) console.log(memTo,value)
                    memory.store(memTo,value);
                };
            };
            var charToPixel = function(digit){
                var pixelConv = {'A':[[0,1,0],[1,0,1],[1,1,1],[1,0,1],[1,0,1]],
                                 'B':[[1,1,0],[1,0,1],[1,1,0],[1,0,1],[1,1,0]],
                                 'C':[[0,1,0],[1,0,1],[1,0,0],[1,0,1],[0,1,0]],
                                 'D':[[1,1,0],[1,0,1],[1,0,1],[1,0,1],[1,1,0]],
                                 'E':[[1,1,1],[1,0,0],[1,1,0],[1,0,0],[1,1,1]],
                                 'F':[[1,1,1],[1,0,0],[1,1,0],[1,0,0],[1,0,0]],
                                 'G':[[1,1,1],[1,0,0],[1,0,1],[1,0,1],[1,1,1]],
                                 'H':[[1,0,1],[1,0,1],[1,1,1],[1,0,1],[1,0,1]],
                                 'I':[[1,1,1],[0,1,0],[0,1,0],[0,1,0],[1,1,1]],
                                 'J':[[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,1,0]],
                                 'K':[[1,0,1],[1,0,1],[1,1,0],[1,0,1],[1,0,1]],
                                 'L':[[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,1,1]],
                                 'M':[[1,0,1],[1,1,1],[1,0,1],[1,0,1],[1,0,1]],
                                 'N':[[1,0,1],[1,1,1],[1,1,1],[1,1,1],[1,0,1]],
                                 'O':[[0,1,0],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
                                 'P':[[1,1,0],[1,0,1],[1,0,1],[1,1,0],[1,0,0]],
                                 'Q':[[0,1,0],[1,0,1],[1,0,1],[0,1,0],[0,0,1]],
                                 'R':[[1,1,0],[1,0,1],[1,1,0],[1,0,1],[1,0,1]],                                
                                 'S':[[0,1,1],[1,0,0],[1,1,1],[0,0,1],[1,1,0]],
                                 'T':[[1,1,1],[0,1,0],[0,1,0],[0,1,0],[0,1,0]],
                                 'U':[[1,0,1],[1,0,1],[1,0,1],[1,0,1],[1,1,1]],
                                 'V':[[1,0,1],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
                                 'W':[[1,0,1],[1,0,1],[1,0,1],[1,1,1],[1,0,1]],
                                 'X':[[1,0,1],[1,1,1],[0,1,0],[1,1,1],[1,0,1]],
                                 'Y':[[1,0,1],[1,0,1],[0,1,0],[0,1,0],[0,1,0]],
                                 'Z':[[1,1,1],[0,0,1],[0,1,0],[1,0,0],[1,1,1]],

                                 'a':[[1,1,0],[0,0,1],[1,1,1],[1,0,1],[1,1,1]],
                                 'b':[[1,0,0],[1,0,0],[1,1,0],[1,0,1],[1,1,0]],
                                 'c':[[0,1,0],[1,0,1],[1,0,0],[1,0,1],[0,1,0]],
                                 'd':[[0,0,1],[0,0,1],[0,1,1],[1,0,1],[0,1,1]],
                                 'e':[[0,1,1],[1,0,1],[1,1,1],[1,0,0],[0,1,1]],
                                 'f':[[0,1,0],[1,0,0],[1,1,0],[1,0,0],[1,0,0]],
                                 'g':[[0,1,1],[1,0,1],[1,1,1],[0,0,1],[1,1,1]],
                                 'h':[[1,0,0],[1,0,0],[1,1,0],[1,0,1],[1,0,1]],
                                 'i':[[0,1,0],[0,0,0],[0,1,0],[0,1,0],[0,1,1]],
                                 'j':[[0,0,1],[0,0,0],[0,0,1],[0,0,1],[0,1,1]],
                                 'k':[[1,0,1],[1,0,1],[1,1,0],[1,0,1],[1,0,1]],
                                 'l':[[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,1,0]],
                                 'm':[[0,0,0],[1,0,1],[1,1,1],[1,0,1],[1,0,1]],
                                 'n':[[0,0,0],[1,0,1],[1,1,1],[1,1,1],[1,0,1]],
                                 'o':[[0,0,0],[0,1,0],[1,0,1],[1,0,1],[0,1,0]],
                                 'p':[[0,1,0],[1,0,1],[1,1,1],[1,0,0],[1,0,0]],
                                 'q':[[0,1,0],[1,0,1],[1,1,1],[0,0,1],[0,0,1]],                                
                                 'r':[[0,0,0],[1,0,1],[1,1,0],[1,0,0],[1,0,0]],
                                 's':[[0,1,1],[1,0,0],[1,1,1],[0,0,1],[1,1,0]],
                                 't':[[1,0,0],[1,1,0],[1,0,0],[1,0,0],[1,0,0]],
                                 'u':[[0,0,0],[1,0,1],[1,0,1],[1,0,1],[1,1,1]],
                                 'v':[[0,0,0],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
                                 'w':[[0,0,0],[1,0,1],[1,0,1],[1,1,1],[1,0,1]],
                                 'x':[[0,0,0],[0,0,0],[1,0,1],[0,1,0],[1,0,1]],
                                 'y':[[0,0,0],[1,0,1],[1,0,1],[0,1,1],[0,0,1]],
                                 'z':[[1,1,1],[0,0,1],[0,1,0],[1,0,0],[1,1,1]],

                                 '0':[[1,1,1],[1,0,1],[1,0,1],[1,0,1],[1,1,1]],
                                 '1':[[0,1,1],[0,0,1],[0,0,1],[0,0,1],[0,0,1]],
                                 '2':[[1,1,0],[0,0,1],[0,1,0],[1,0,0],[1,1,1]],
                                 '3':[[1,1,0],[0,0,1],[0,1,1],[0,0,1],[1,1,0]],
                                 '4':[[1,0,1],[1,0,1],[1,1,1],[0,0,1],[0,0,1]],
                                 '5':[[1,1,1],[1,0,0],[1,1,1],[0,0,1],[1,1,1]],
                                 '6':[[1,1,1],[1,0,0],[1,1,1],[1,0,1],[1,1,1]],
                                 '7':[[1,1,1],[0,0,1],[0,1,0],[1,0,0],[1,0,0]],
                                 '8':[[1,1,1],[1,0,1],[0,1,0],[1,0,1],[1,1,1]],
                                 '9':[[1,1,1],[1,0,1],[1,1,1],[0,0,1],[1,1,1]],

                                 '+':[[0,0,0],[0,1,0],[1,1,1],[0,1,0],[0,0,0]],
                                 '-':[[0,0,0],[0,0,0],[1,1,1],[0,0,0],[0,0,0]],
                                 '*':[[0,0,0],[1,0,1],[0,1,0],[1,0,1],[0,0,0]],
                                 '(':[[0,1,0],[1,0,0],[1,0,0],[1,0,0],[0,1,0]],
                                 ')':[[0,1,0],[0,0,1],[0,0,1],[0,0,1],[0,1,0]],
                                 '[':[[1,1,0],[1,0,0],[1,0,0],[1,0,0],[1,1,0]],
                                 ']':[[0,1,1],[0,0,1],[0,0,1],[0,0,1],[0,1,1]],
                                 '!':[[0,1,0],[0,1,0],[0,1,0],[0,0,0],[0,1,0]],
                                 '?':[[1,1,0],[0,0,1],[0,1,0],[0,0,0],[0,1,0]],
                                 '=':[[0,0,0],[1,1,1],[0,0,0],[1,1,1],[0,0,0]],
                                 '/':[[0,0,1],[0,1,1],[0,1,0],[1,1,0],[1,0,0]],
                                 '%':[[1,0,1],[0,1,1],[0,1,0],[1,1,0],[1,0,1]],
                                 '.':[[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,1,0]],
                                 ',':[[0,0,0],[0,0,0],[0,0,0],[0,1,0],[1,0,0]],
                                 ';':[[0,0,0],[0,1,0],[0,0,0],[0,1,0],[1,0,0]],
                                 '<':[[0,0,0],[0,1,1],[1,0,0],[0,1,1],[0,0,0]],
                                 '>':[[0,0,0],[1,1,0],[0,1,0],[1,1,0],[0,0,0]],
                                 ' ':[[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],

                                };
                
                var pixelmap = pixelConv[digit];
                if (pixelmap==undefined){
                    pixelmap =[[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]];
                };
                return pixelConv[digit]
            };
            
            switch (routineCode){
                case 0: 
                    WaitSec();
                    break;
                // case 2:
                //     WaitKey();
                //     break;
                case 10:
                    DisplayBinaryDigit(A,B);
                    break;
                case 12:
                    DisplayHexaDigit(A,B);
                    break;
                case 14:
                    DisplayHexaByte(A,B);
                    break;
                case 16:
                    DisplayCharDigit(A,B);
                    break;
                case 20:
                    ClearScreen();
                    break;
                case 22:
                    SetPixel(X,Y);
                    break;
                case 24:
                    ClrPixel(X,Y);
                    break;
                case 26:
                    NotPixel(X,Y);
                    break;
                case 28:
                    value = TestPixel(X,Y);
                    return ['zero',value];
                    break;
                case 40:
                    DrawChar(A,X,Y);
                    break;
                case 42:
                    DrawHexaDigit(A,X,Y);
                    break;
                case 44:
                    DrawHexaByte(A,X,Y);
                    break;
                default:
                    throw 'invalid routine: ' + routineCode.toString()
            };
        }
    };
   return routines; 
}]);

//NK 14/7
;app.service('bus', ['memory', function (memory) {
    var bus = {
        address: 0,
        data: 0,
        read: function () {
            console.log(this)
            var self = this;
            self.data = memory.load(self.address);
        },
        write: function () {
            console.log(this)
            var self = this;
            memory.store(self.address, self.data);
        },
        change: function (flag, bitIndex, bitValue) {
            var self = this;
            
            switch (flag) {
                case 'address':
                    var valChange = 2**(11-bitIndex);
                    if (bitValue==1){
                        self.address -= valChange;
                    } else{
                        self.address += valChange;
                    };
                    break;
                case 'data':
                    var valChange = 2**(7-bitIndex);
                    if (bitValue==1){
                        self.data -= valChange;
                    } else{
                        self.data += valChange;
                    };
                    break;
            };
        },
        update: function (address) {
            var self = this;
            self.address = address;
            self.data = memory.load(self.address);
        },
        reset: function () {
            var self = this;
            self.address = 0;
            self.data = 0;
        }
    };
    bus.reset();
    return bus;
}]);
;app.service('opcodes', [function() {
    var opcodes = {
        MOVE_A_TO_A: 64, MOVE_A_TO_B: 65, MOVE_A_TO_X: 66, MOVE_A_TO_Y: 67,
        MOVE_B_TO_A: 68, MOVE_B_TO_B: 69, MOVE_B_TO_X: 70, MOVE_B_TO_Y: 71,
        MOVE_X_TO_A: 72, MOVE_X_TO_B: 73, MOVE_X_TO_X: 74, MOVE_X_TO_Y: 75,
        MOVE_Y_TO_A: 76, MOVE_Y_TO_B: 77, MOVE_Y_TO_X: 78, MOVE_Y_TO_Y: 79,
        MOVE_NUMBER_TO_A: 80, MOVE_NUMBER_TO_B: 81, MOVE_NUMBER_TO_X: 82, MOVE_NUMBER_TO_Y: 83,
        MOVE_ADDRESS_TO_A: 84, MOVE_ADDRESS_TO_B: 85, MOVE_ADDRESS_TO_X: 86, MOVE_ADDRESS_TO_Y: 87,
        MOVE_A_TO_ADDRESS: 88, MOVE_B_TO_ADDRESS: 89, MOVE_X_TO_ADDRESS: 90, MOVE_Y_TO_ADDRESS: 91,
        MOVE_NUMBER_TO_ADDRESS: 220,
        ADD_A_TO_A: 128, ADD_A_TO_B: 129, ADD_A_TO_X: 130, ADD_A_TO_Y: 131, 
        ADD_B_TO_A: 132, ADD_B_TO_B: 133, ADD_B_TO_X: 134, ADD_B_TO_Y: 135, 
        ADD_X_TO_A: 136, ADD_X_TO_B: 137, ADD_X_TO_X: 138, ADD_X_TO_Y: 139, 
        ADD_Y_TO_A: 140, ADD_Y_TO_B: 141, ADD_Y_TO_X: 142, ADD_Y_TO_Y: 143, 
        ADD_NUMBER_TO_A: 160, ADD_NUMBER_TO_B: 161, ADD_NUMBER_TO_X: 162, ADD_NUMBER_TO_Y: 163,
        ADD_ADDRESS_TO_A: 176, ADD_ADDRESS_TO_B: 177, ADD_ADDRESS_TO_X: 178, ADD_ADDRESS_TO_Y: 179,
        ADD_A_TO_ADDRESS: 184, ADD_B_TO_ADDRESS: 185, ADD_X_TO_ADDRESS: 186, ADD_Y_TO_ADDRESS: 187, 
        ADD_NUMBER_TO_ADDRESS: 222,
        SUB_A_TO_A: 144, SUB_A_TO_B: 145, SUB_A_TO_X: 146, SUB_A_TO_Y: 147, 
        SUB_B_TO_A: 148, SUB_B_TO_B: 149, SUB_B_TO_X: 150, SUB_B_TO_Y: 151, 
        SUB_X_TO_A: 152, SUB_X_TO_B: 153, SUB_X_TO_X: 154, SUB_X_TO_Y: 155, 
        SUB_Y_TO_A: 156, SUB_Y_TO_B: 157, SUB_Y_TO_X: 158, SUB_Y_TO_Y: 159, 
        SUB_NUMBER_TO_A: 164, SUB_NUMBER_TO_B: 165, SUB_NUMBER_TO_X: 166, SUB_NUMBER_TO_Y: 167,
        SUB_ADDRESS_TO_A: 180, SUB_ADDRESS_TO_B: 181, SUB_ADDRESS_TO_X: 182, SUB_ADDRESS_TO_Y: 183,
        SUB_A_TO_ADDRESS: 188, SUB_B_TO_ADDRESS: 189, SUB_X_TO_ADDRESS: 190, SUB_Y_TO_ADDRESS: 191, 
        SUB_NUMBER_TO_ADDRESS: 223,
        AND_A_TO_B: 224, AND_B_TO_A: 225,
        AND_NUMBER_TO_A: 116, AND_NUMBER_TO_B: 117, AND_NUMBER_TO_X: 118, AND_NUMBER_TO_Y: 119,
        AND_ADDRESS_TO_A: 232, AND_ADDRESS_TO_B: 233,
        AND_A_TO_ADDRESS: 240, AND_B_TO_ADDRESS: 241,
        OR_A_TO_B: 226, OR_B_TO_A: 227,
        OR_NUMBER_TO_A: 120, OR_NUMBER_TO_B: 121, OR_NUMBER_TO_X: 122, OR_NUMBER_TO_Y: 123,
        OR_ADDRESS_TO_A: 234, OR_ADDRESS_TO_B: 235,
        OR_A_TO_ADDRESS: 242, OR_B_TO_ADDRESS: 243,
        XOR_A_TO_B: 228, XOR_B_TO_A: 229,
        XOR_NUMBER_TO_A: 124, XOR_NUMBER_TO_B: 125, XOR_NUMBER_TO_X: 126, XOR_NUMBER_TO_Y: 127,
        XOR_ADDRESS_TO_A: 236, XOR_ADDRESS_TO_B: 237,
        XOR_A_TO_ADDRESS: 244, XOR_B_TO_ADDRESS: 245,

        TEST_B_A: 192, TEST_A_B: 193,
        TEST_A_NUMBER: 208, TEST_B_NUMBER: 209,  
        TEST_ADDRESS_A: 200, TEST_ADDRESS_B: 201, TEST_ADDRESS_NUMBER: 216,

        TSET_B_A: 194, TSET_A_B: 195,
        TSET_A_NUMBER: 210, TSET_B_NUMBER: 211, 
        TSET_ADDRESS_A: 202, TSET_ADDRESS_B: 203, TSET_ADDRESS_NUMBER: 217,

        TCLR_B_A: 196, TCLR_A_B: 197,
        TCLR_A_NUMBER: 212, TCLR_B_NUMBER: 213, 
        TCLR_ADDRESS_A: 204, TCLR_ADDRESS_B: 205, TCLR_ADDRESS_NUMBER: 218,

        TNOT_B_A: 198, TNOT_A_B: 199,
        TNOT_A_NUMBER: 214, TNOT_B_NUMBER: 215, 
        TNOT_ADDRESS_A: 206, TNOT_ADDRESS_B: 207, TNOT_ADDRESS_NUMBER: 219,

        COMP_A_TO_A: 96, COMP_A_TO_B: 97, COMP_A_TO_X: 98, COMP_A_TO_Y: 99,
        COMP_B_TO_A: 100, COMP_B_TO_B: 101, COMP_B_TO_X: 102, COMP_B_TO_Y: 103,
        COMP_X_TO_A: 104, COMP_X_TO_B: 105, COMP_X_TO_X: 106, COMP_X_TO_Y: 107,
        COMP_Y_TO_A: 108, COMP_Y_TO_B: 109, COMP_Y_TO_X: 110, COMP_Y_TO_Y: 111,
        COMP_NUMBER_TO_A: 112, COMP_NUMBER_TO_B: 113, COMP_NUMBER_TO_X: 114, COMP_NUMBER_TO_Y: 115,
        COMP_ADDRESS_TO_A: 248, COMP_ADDRESS_TO_B: 249, COMP_ADDRESS_TO_X: 250, COMP_ADDRESS_TO_Y: 251,
        COMP_NUMBER_TO_ADDRESS: 221,
        CLR_A: 32, CLR_B: 33, CLR_X: 34, CLR_Y: 35,
        NOT_A: 36, NOT_B: 37, NOT_X: 38, NOT_Y: 39,
        INC_A: 40, INC_B: 41, INC_X: 42, INC_Y: 43,
        DEC_A: 44, DEC_B: 45, DEC_X: 46, DEC_Y: 47,
        CLR_ADDRESS: 168,
        NOT_ADDRESS: 169,
        INC_ADDRESS: 170,
        DEC_ADDRESS: 171,
        RL_A: 48, RL_B: 49, RL_X: 50, RL_Y: 51,
        RR_A: 52, RR_B: 53, RR_X: 54, RR_Y: 55,
        RLC_A: 56, RLC_B: 57, RLC_X: 58, RLC_Y: 59,
        RRC_A: 60, RRC_B: 61, RRC_X: 62, RRC_Y: 63,
        RL_ADDRESS: 172,
        RR_ADDRESS: 173,
        RLC_ADDRESS: 174,
        RRC_ADDRESS: 175,
        JUMP_ADDRESS: 16,
        JUMP_EQ_ADDRESS: 18,
        JUMP_ZS_ADDRESS: 18,
        JUMP_NE_ADDRESS: 19,
        JUMP_ZC_ADDRESS: 19,
        JUMP_LO_ADDRESS: 20,
        JUMP_CS_ADDRESS: 20,
        JUMP_HS_ADDRESS: 21,
        JUMP_CC_ADDRESS: 21,
        JUMP_LS_ADDRESS: 22,
        JUMP_HI_ADDRESS: 23,
        JUMP_NS_ADDRESS: 24,
        JUMP_NC_ADDRESS: 25,
        CALL_ADDRESS: 1,
        CALL_ROUTINE: 255,
        RET: 2,
        PUSH_A: 8, PUSH_B: 9, PUSH_X: 10, PUSH_Y: 11,
        PUSH_F: 252,
        POP_A: 12, POP_B: 13, POP_X: 14, POP_Y: 15,
        POP_F: 253,
        SUB_NUMBER_TO_SP: 7,
        ADD_NUMBER_TO_SP: 6,
        MOVE_SP_NUMBER_TO_A: 84, MOVE_SP_NUMBER_TO_B: 85, MOVE_SP_NUMBER_TO_X: 86, MOVE_SP_NUMBER_TO_Y: 87,
        MOVE_A_TO_SP_NUMBER: 88, MOVE_B_TO_SP_NUMBER: 89, MOVE_X_TO_SP_NUMBER: 90, MOVE_Y_TO_SP_NUMBER: 91,
        SETC: 4,
        CLRC: 5,
        NOTC: 254,
        NOP: 0,
        HALT: 3,
        EX_A_WITH_B: 92,
        EX_X_WITH_Y: 93,
        SWAP_A: 94,
        SWAP_B: 95     
    };
    
    return opcodes;
}]);
// NK 
;app.service('constants', [function(archi=8) {
    // nk constantes
    // type: js-internal to script (no _ in the name) / number: 8bits / address: 12 bits
    var memory_size = 2**archi;
    var bitmap_length = 128;
    var bitmap_line = parseInt(bitmap_length/4);
    var digit_length = 4;
    var ascii_length = 24;
    var constants ={'MEMOMRYSIZE': {'value':memory_size,'type':'js'},
                    '_DIGIT0': {'value': memory_size -bitmap_length - digit_length, 'type':'address'},
                    '_DIGIT1': {'value': memory_size -bitmap_length - digit_length+1, 'type':'address'},
                    '_DIGIT2': {'value': memory_size -bitmap_length - digit_length+2, 'type':'address'},
                    '_DIGIT3': {'value': memory_size -bitmap_length - digit_length+3, 'type':'address'},
                    '_DIGITLENGTH': {'value': digit_length, 'type':'number'},
                    '_BITMAP': {'value': memory_size -bitmap_length ,'type':'address'},
                    '_BITMAPLENGTH': {'value': bitmap_length , 'type':'number'},
                    '_BITMAPWIDTH': {'value': bitmap_length/bitmap_line *8 , 'type':'number'},
                    '_BITMAPHEIGHT': {'value': bitmap_line , 'type':'number'},
                    '_ASCII': {'value': memory_size -bitmap_length -digit_length -ascii_length, 'type':'address'},
                    '_ASCIILENGTH': {'value': ascii_length, 'type':'number'},
                    '_KEYBOARD': {'value': memory_size -bitmap_length -digit_length -ascii_length -1, 'type':'address'},
                    '_KEYBOARDSHIFT': {'value': 3, 'type':'number'},
                    '_KEYBOARDCTRL'	: {'value': 4, 'type':'number'},
                    '_KEYBOARDDOWN'	: {'value': 3, 'type':'number'},
                    '_KEYBOARDUP'	: {'value': 4, 'type':'number'},
                    '_KEYBOARDLEFT' : {'value': 5, 'type':'number'},
                    '_KEYBOARDRIGHT': {'value': 6, 'type':'number'},
                    '_KEYBOARDFULL'	: {'value': 7, 'type':'number'},
                    '_WAITSEC':{'value': 0, 'type':'routine'},
                    '_WAITKEY':{'value': 2, 'type':'routine'},
                    '_DISPLAYBINARYDIGIT':{'value': 10, 'type':'routine'},
                    '_DISPLAYHEXADIGIT':{'value': 12, 'type':'routine'},
                    '_DISPLAYHEXABYTE':{'value': 14, 'type':'routine'},
                    '_DISPLAYCHARDIGIT':{'value': 16, 'type':'routine'},
                    '_CLEARSCREEN':{'value': 20, 'type':'routine'},
                    '_SETPIXEL':{'value': 22, 'type':'routine'},
                    '_CLRPIXEL':{'value': 24, 'type':'routine'},
                    '_NOTPIXEL':{'value': 26, 'type':'routine'},
                    '_TESTPIXEL':{'value': 28, 'type':'routine'},
                    '_DRAWCHAR':{'value': 40, 'type':'routine'},
                    '_DRAWHEXADIGIT':{'value': 42, 'type':'routine'},
                    '_DRAWHEXABYTE':{'value': 44, 'type':'routine'},
                set:function(archi){ 
                    var self = this;
                    var memory_size = 2**archi;
                    self.MEMOMRYSIZE.value = memory_size;
                    self._DIGIT0.value = memory_size -bitmap_length - digit_length;
                    self._DIGIT1.value = memory_size -bitmap_length - digit_length+1;
                    self._DIGIT2.value = memory_size -bitmap_length - digit_length+2;
                    self._DIGIT3.value = memory_size -bitmap_length - digit_length+3;
                    self._BITMAP.value =memory_size -bitmap_length ;
                    self._ASCII.value = memory_size -bitmap_length -digit_length -ascii_length;
                    self._ASCIILENGTH.value = ascii_length;
                    self._KEYBOARD.value =memory_size -bitmap_length -digit_length -ascii_length -1;
                }
                };
    constants.set(archi)
    return constants;
}]);

;app.controller('Ctrl', ['$document', '$scope', '$timeout', 'cpu', 'memory', 'assembler', 'bus', 'constants', function ($document, $scope, $timeout, cpu, memory, assembler, bus, constants) {
    var debug = false;
    
    $scope.memory = memory;
    $scope.cpu = cpu;
    $scope.bus = bus;
    $scope.error = '';
    $scope.isRunning = false;
    $scope.displayHex = false;
    $scope.displayInstr = true;
    $scope.displayAdd = false; // show or hide memory address
    $scope.displayA = true;
    $scope.displayB = true;
    $scope.displayC = true;
    $scope.displayD = true;
    $scope.speeds = [{speed: 1, desc: "1 HZ"},
                     {speed: 4, desc: "4 HZ"},
                     {speed: 8, desc: "8 HZ"},
                     {speed: 16, desc: "16 HZ"},
                     {speed: 128, desc: "128 HZ"},
                    //  {speed: 8192, desc: "8192 HZ"},
                     {speed: 1048576, desc: "1 MHZ"}];
    $scope.speed = 16;
    $scope.archis = [{archi: 8, desc: "256 B"},
                    {archi: 9, desc: "512 B"},
                    {archi: 12, desc: "4096 B"}];
    $scope.archi = 8;
    constants.set($scope.archi);
    $scope.constants = constants;
    memory.reset();

    //nk 29/06
    // $scope.outputs = [{output: "ASCII", desc: "ASCII"},
    //                   {output: "DIGIT", desc: "Digit"},
    //                   {output: "IMG", desc: "Pixel"}]

    //
    // $scope.pileStop = $scope.constants._KEYBOARD.value-1;


    // $scope.output = "ASCII";
    // $scope.outputStartIndex = $scope.constants._ASCII.value;
    // $scope.outputStopIndex = $scope.constants._ASCIILENGTH.value;; 
    
    // $scope.outputChange = function (){
    //     if ($scope.output=== "ASCII"){
    //         $scope.outputStartIndex = $scope.constants._ASCII.value;
    //         $scope.outputStopIndex = $scope.constants._ASCIILENGTH.value; 
    //     } else if ($scope.output=== "DIGIT"){
    //         $scope.outputStartIndex = $scope.constants._DIGIT0.value;
    //         $scope.outputStopIndex = $scope.constants._DIGITLENGTH.value; 
    //     } else if ($scope.output=== "IMG"){
    //         $scope.outputStartIndex =  $scope.constants._BITMAP.value;
    //         $scope.outputStopIndex =  $scope.constants._BITMAPLENGTH.value; 
    //     };
    // };
    $scope.output=[true, true, true]
    $scope.outputChange = function (output=undefined){
        if (output != undefined){
            if (output=="ASCII"){
                $scope.output[0] = !$scope.output[0];
            } else if (output=="DIGIT"){
                $scope.output[1] = !$scope.output[1];
            } else if (output=="IMG"){
                $scope.output[2] = !$scope.output[2];
            }
        }
        $scope.outputStartIndex_ASCII = $scope.constants._ASCII.value;
        $scope.outputStopIndex_ASCII = $scope.constants._ASCIILENGTH.value; 
        $scope.outputStartIndex_DIGIT = $scope.constants._DIGIT0.value;
        $scope.outputStopIndex_DIGIT = $scope.constants._DIGITLENGTH.value; 
        $scope.outputStartIndex_BITMAP =  $scope.constants._BITMAP.value;
        $scope.outputStopIndex_BITMAP =  $scope.constants._BITMAPLENGTH.value; 
    }
    $scope.outputChange()
    
    $scope.memorySize = function (){
        if ($scope.constants.MEMOMRYSIZE.value==256){
            $scope.adressSize = 8;
        } else if ($scope.constants.MEMOMRYSIZE.value==512){
            $scope.adressSize = 9;
        } else if ($scope.constants.MEMOMRYSIZE.value==1024){
            $scope.adressSize = 10;
        } else if ($scope.constants.MEMOMRYSIZE.value==2048){
            $scope.adressSize = 11;
        } else if ($scope.constants.MEMOMRYSIZE.value==4096){
            $scope.adressSize = 12;
        }
    }
    $scope.memorySize()
    
    // ng-model "code" est un l'intérieur d'un ng-switch donc obligé de passer par un abojet pour l'heritage
    $scope.code = {text: "START: \n	MOVE	#0, X		; rang de la lettre\nDISPLAY:\n	MOVE	#0, Y		; rang de l'afficheur\nLOOP:\n	MOVE	TABLE+{X}+{Y}, A	; cherche la lettre\n	MOVE	A, _ASCII+{Y}	; affiche la lettre\n	INC	Y		; afficheur suivant\n	COMP	#4, Y		; 4ème afficheur ?\n	JUMP,LO	LOOP		; non -> LOOP\n				; oui ->\n	MOVE	#3, A		; durée à attendre\n	\n	INC	X		; lettre suivante\n	COMP	#12-4, X		; dernière lettre ?\n	JUMP,LS	DISPLAY		; non -> DISPLAY\n	JUMP	START		; oui -> START\n\n	TABLE	#12		; table de 12 octets\nTABLE:\n	BYTE	#\"_\"	; espace\n	BYTE	#\"_\"	; espace\n	BYTE	#\"_\"	; espace\n	BYTE	#\"H\"	; lettre H\n	BYTE	#\"E\"	; lettre E\n	BYTE	#\"L\"	; lettre L\n	BYTE	#\"L\"	; lettre L\n	BYTE	#\"O\"	; lettre O\n	BYTE	#\"_\"	; espace\n	BYTE	#\"_\"	; espace\n	BYTE	#\"_\"	; espace\n	BYTE	#\"_\"	; espace\n"};

    
    $scope.reset = function () {
        cpu.reset();
        memory.reset();
        bus.reset(); //NK
        $scope.error = '';
        $scope.selectedLine = -1;
        $scope.selectedLine_assemble  = -1 // NK
    };

    $scope.executeStep = function () {
        if (!$scope.checkPrgrmLoaded()) {
            $scope.assemble();
        }
        var turbo = $document[0].getElementById('btn-turbo').value==1;

        try {
            // Execute
            var res = cpu.step();

            // Mark in code
            if (cpu.pc in $scope.mapping && !turbo) {
                $scope.selectedLine = $scope.mapping[cpu.pc][0];     
                $scope.selectedLine_assemble = $scope.mapping[cpu.pc][1];
            }

            return res;
        } catch (e) {
            $scope.error = e;
            return false;
        }
    };

    var runner;
    $scope.run = function () {
        if (!$scope.checkPrgrmLoaded()) {
            $scope.assemble();
        }
        var turbo = $document[0].getElementById('btn-turbo').value==1;

        $scope.isRunning = true;
        if (!turbo){
            runner = $timeout(function () {
                if ($scope.executeStep() === true) {
                    $scope.run();
                } else {
                    $scope.isRunning = false;
                }
            }, 1000 / $scope.speed);
        }else{
            $timeout(function () {
                if ($scope.executeStep() === true) {
                    $scope.run();
                } else {
                    $scope.isRunning = false;
                }
            }, 0);

        };
    };

    $scope.stop = function () {
        $timeout.cancel(runner);
        $scope.isRunning = false;
    };

    $scope.checkPrgrmLoaded = function () {
        for (var i = 0, l = memory.data.length; i < l; i++) {
            if (memory.data[i] !== 0) {
                return true;
            }
        }

        return false;
    };

    $scope.getChar = function (value) {
        var text = String.fromCharCode(value);

        if (text.trim() === '') {
            return '\u00A0\u00A0';
        } else {
            return text;
        }
    };

    $scope.getBin = function (value) {
        var bin = value.toString(2);
        if (bin.length <8){
            bin = "0".repeat(8-bin.length) + bin
        }
        // return "010" + bin
        return bin  
    };
    $scope.getBinArray = function (value, binlength = 8) {
        var bin = value.toString(2);
        // console.log(bin)
        if (bin.length <binlength){
            bin = "0".repeat(binlength-bin.length) + bin
        }
        // console.log(bin)
        // return "010" + bin
        return bin.split("")
    };

    $scope.assemble = function () {
        try {
            $scope.reset();
            var assembly = assembler.go($scope.code.text);
            $scope.mapping = assembly.mapping;
            var binary = assembly.code;
            $scope.labels = assembly.labels;
            $scope.labels_dauph = assembly.labels_dauph;

            if (binary.length > memory.data.length)
                throw "Binary code does not fit into the memory. Max " + memory.data.length + " bytes are allowed";

            for (var i = 0, l = binary.length; i < l; i++) {
                memory.data[i] = binary[i];
            }
        } catch (e) {
            if (e.line !== undefined) {
                $scope.error = e.line + " | " + e.error;
                $scope.selectedLine = e.line;
            } else {
                $scope.error = e.error;
            }
        }
    };

    $scope.turbo = function(){
        var val = $document[0].getElementById('btn-turbo').value;
        var turboClass = $document[0].querySelectorAll('.turbo');
        if (val==0) {
            $document[0].getElementById('btn-turbo').setAttribute("value",1);
            $document[0].getElementById('btn-turbo').setAttribute("style","background-color:#ff9090");
            for (i=0; i<turboClass.length; i++){
                turboClass[i].setAttribute("style","display:none");
            }
        }else if (val==1){
             $document[0].getElementById('btn-turbo').setAttribute("value",0);
             $document[0].getElementById('btn-turbo').setAttribute("style","background-color:#fff");
             for (i=0; i<turboClass.length; i++){
                turboClass[i].setAttribute("style","min-width:33em");
            }
        };
    }

    $scope.jumpToLine = function (index) {
        $document[0].getElementById('sourceCode').scrollIntoView();
        $scope.selectedLine = $scope.mapping[index][0];
        $scope.selectedLine_assemble = $scope.mapping[index][1];
    };

    //NK
    $scope.changeMemory = function (byteIndex, bitIndex, bitValue, output) {
        if (output==1){
            var ad = byteIndex+$scope.outputStartIndex_DIGIT
        } else if (output==2){
            var ad = byteIndex+$scope.outputStartIndex_BITMAP
        }
        var valChange = 2**(7-bitIndex)
        if (bitValue==0){
            memory.store(ad,memory.data[ad]+valChange)
        } else {
            memory.store(ad,memory.data[ad]-valChange)
        }
    };


    $scope.isInstruction = function (index) {
        return $scope.mapping !== undefined &&
            $scope.mapping[index] !== undefined &&
            $scope.displayInstr;
    };

    $scope.getMemoryCellCss = function (index) {
        if (index >= $scope.outputStartIndex_ASCII && index <= $scope.outputStartIndex_ASCII + $scope.outputStopIndex_ASCII - 1) { //NK 29/06
            return 'output-bg1';
        } else if (index >= $scope.outputStartIndex_DIGIT && index <= $scope.outputStartIndex_DIGIT + $scope.outputStopIndex_DIGIT - 1) {
            return 'output-bg2';
        } else if (index >= $scope.outputStartIndex_BITMAP && index <= $scope.outputStartIndex_BITMAP + $scope.outputStopIndex_BITMAP - 1) {
            return 'output-bg3';
        } else if ($scope.isInstruction(index)) {
            return 'instr-bg';
        } else if (index > cpu.sp && index <= cpu.maxSP) {
            return 'stack-bg';
        } else {
            return '';
        }
    };

    $scope.getMemoryInnerCellCss = function (index) {
        if (index === cpu.pc) {
            return 'marker marker-pc';
        } else if (index === cpu.sp) {
            return 'marker marker-sp';
        } else if (index === cpu.gpr[0] && $scope.displayA) {
            return 'marker marker-a';
        } else if (index === cpu.gpr[1] && $scope.displayB) {
            return 'marker marker-b';
        } else if (index === cpu.gpr[2] && $scope.displayC) {
            return 'marker marker-x';
        } else if (index === cpu.gpr[3] && $scope.displayD) {
            return 'marker marker-y';
        } else {
            return '';
        }
    };

    $scope.getOutputImgInnerCellCss = function (bitval) {
        if (bitval == 0) {
            return 'outputImg outputImg-off';
        } else if (bitval == 1) {
            return 'outputImg outputImg-on';
        }
    };
    $scope.getOutputDigitInnerCellCss = function (bitval) {
        if (bitval == 0) {
            return 'outputDigit outputDigit-off';
        } else if (bitval == 1) {
            return 'outputDigit outputDigit-on';
        }
    };
    $scope.getOutputCss = function () {
        if ($scope.output[0]){
            $document[0].getElementById("btn-output-ascii").className = 'btn btn-default btn-output-on'           
        } else {
            $document[0].getElementById("btn-output-ascii").className = 'btn btn-default'    
        }
        if ($scope.output[1]){
            $document[0].getElementById("btn-output-digit").className = 'btn btn-default btn-output-on'
        } else {
            $document[0].getElementById("btn-output-digit").className = 'btn btn-default'
        }
        if ($scope.output[2]){
            $document[0].getElementById("btn-output-img").className = 'btn btn-default btn-output-on'
        } else{
            $document[0].getElementById("btn-output-img").className = 'btn btn-default'
        }
    }
    $scope.getCodeCss = function (e) {
        if (e == 'assemble'){
            $document[0].getElementById("btn-code-texte").className = 'btn btn-default'
            $document[0].getElementById("btn-code-assemble").className = 'btn btn-default btn-code-on'           

        } else if (e == 'texte'){
            $document[0].getElementById("btn-code-texte").className = 'btn btn-default btn-code-on'
            $document[0].getElementById("btn-code-assemble").className = 'btn btn-default'
        } 
    }
    'btn btn-default btn-view-on' 
    $scope.getViewCss = function () {
        if ($scope.displayHex  == true) {
            $document[0].getElementById("btn-view-hex").className = 'btn btn-default btn-view-on'
            $document[0].getElementById("btn-view-dec").className = 'btn btn-default' 
        } else  {
            $document[0].getElementById("btn-view-hex").className = 'btn btn-default'
            $document[0].getElementById("btn-view-dec").className = 'btn btn-default btn-view-on' 
        }
    };
    $scope.getBusInnerCellCss = function (bitval) {
        if (bitval == 0) {
            return 'btn-bus btn-bus-off';
        } else if (bitval == 1) {
            return 'btn-bus btn-bus-on';
        }
    };
    $scope.inputClick = function (bitIndex){
        var ad = $scope.constants._KEYBOARD.value; 
        var bitValue = $scope.getBinArray(memory.data[ad])[7-bitIndex];
        var valChange = 2**(bitIndex);

        if (bitValue==0){
            memory.store(ad,memory.data[ad]+valChange);
        } else {
            memory.store(ad,memory.data[ad]-valChange);
        }
    };
    $scope.getInputCss = function (bitIndex) {
        var ad = $scope.constants._KEYBOARD.value; 
        var bitValue = $scope.getBinArray(memory.data[ad])[7-bitIndex];
        if (bitValue == 0) {
            return 'btn btn-input btn-input-off';
        } else if (bitValue == 1) {
            return 'btn btn-input btn-input-on';
        }
    };


    $scope.readFile = function (filename) {
        var reader = new FileReader();
        reader.readAsText(filename[0]);
        reader.onload = function() {
            $scope.code.text=reader.result;
            document.getElementById('sourceCode').value = reader.result;
        };
    };
    $scope.writeFile = function (filename) {
        var file = new Blob([$scope.code.text],{type:"text"});
        var anchor = document.createElement('a');
        anchor.href = URL.createObjectURL(file);
        anchor.download='Assembleur.txt';
        anchor.click();        
    };

}]);
;app.filter('flag', function() {
    return function(input) {
        return input.toString().toUpperCase();
    };
});
;app.filter('number', function() {
    return function(input, isHex) {
        if (!Array.isArray(input)){
            if (isHex) {
                var hex = input.toString(16).toUpperCase();
                return hex.length == 1 ? "0" + hex: hex;
            } else {
                var dec = input.toString(10);
                return dec.length == 1 ? "0" + dec: dec;
            };
        } else { //NK pour labels_dauph (code_assemble)
            var output = ""
            for (i = 0, l = input.length; i < l; i++) {
                if (isHex) {
                    var hex = input[i].toString(16).toUpperCase();
                    output += (hex.length == 1 ? "0" + hex: hex);
                    
                } else{
                    var dec = input[i].toString(10);
                    output += (dec.length == 1 ? "0" + dec: dec);
                }
                output += " ";
            };
            return output;
        }
    };
});
;// Source: http://lostsource.com/2012/11/30/selecting-textarea-line.html
app.directive('selectLine', [function () {
    return {
        restrict: 'A',
        link: function (scope, element, attrs, controller) {
            scope.$watch('selectedLine', function () {
                if (scope.selectedLine >= 0) {
                    var lines = element[0].value.split("\n");

                    // Calculate start/end
                    var startPos = 0;
                    for (var x = 0; x < lines.length; x++) {
                        if (x == scope.selectedLine) {
                            break;
                        }
                        startPos += (lines[x].length + 1);
                    }

                    var endPos = lines[scope.selectedLine].length + startPos;

                    // Chrome / Firefox
                    if (typeof(element[0].selectionStart) != "undefined") {
                        element[0].focus();
                        element[0].selectionStart = startPos;
                        element[0].selectionEnd = endPos;
                    }

                    // IE
                    if (document.selection && document.selection.createRange) {
                        element[0].focus();
                        element[0].select();
                        var range = document.selection.createRange();
                        range.collapse(true);
                        range.moveEnd("character", endPos);
                        range.moveStart("character", startPos);
                        range.select();
                    }
                }
            });
        }
    };
}]);
app.directive('selectRow', [function () {
    return {
        restrict: 'A',
        link: function (scope, element, attrs, controller) {
            scope.$watch('selectedLine_assemble', function () {
                if (scope.selectedLine_assemble >= 0) {
                    var rows = document.querySelectorAll("#table-assemble tr");
                    var startPos = 0;
                    for (var i = 0; i < rows.length; i++) {
                        if (i==scope.selectedLine_assemble){
                            rows[i].classList.add('row-highlight')
                        } else {
                            rows[i].classList.remove('row-highlight')
                        }
                    }
                }
            });
        }
    }
}]);





;app.filter('startFrom', function() {
    return function(input, start) {
        start = +start; //parse to int
        return input.slice(start);
    };
});
// NK 6/7
;app.filter('stopTo', function() {
    return function(input, stop) {
        return input.slice(0, stop);
    };
});

;app.directive('tabSupport', [function () {
    return {
        restrict: 'A',
        link: function (scope, element, attrs, controller) {
            element.bind("keydown", function (e) {
                if (e.keyCode === 9) {
                    var val = this.value;
                    var start = this.selectionStart;
                    var end = this.selectionEnd;

                    this.value = val.substring(0, start) + '\t' + val.substring(end);
                    this.selectionStart = this.selectionEnd = start + 1;

                    e.preventDefault();
                    return false;
                }
            });
        }
    };
}]);

